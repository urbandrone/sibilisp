(comment sibilisp-prelude - MIT)

(provide
 (defun identity (a) a))

(provide
 (defun constant (a)
	 (lambda () a)))

(provide
 (defun set-arity (ln func)
	 (cond ((< ln 1) (lambda ()
										 (.apply func (nil) arguments)))
				 ((< ln 2) (lambda (a)
										 (.apply func (nil) arguments)))
				 ((< ln 3) (lambda (a b)
										 (.apply func (nil) arguments)))
				 ((< ln 4) (lambda (a b c)
										 (.apply func (nil) arguments)))
				 ((< ln 5) (lambda (a b c d)
										 (.apply func (nil) arguments)))
				 ((< ln 6) (lambda (a b c d e)
										 (.apply func (nil) arguments)))
				 ((< ln 7) (lambda (a b c d e f)
										 (.apply func (nil) arguments)))
				 ((< ln 8) (lambda (a b c d e f g)
										 (.apply func (nil) arguments)))
				 ((< ln 9) (lambda (a b c d e f g h)
										 (.apply func (nil) arguments)))
				 ((< ln 10) (lambda (a b c d e f g h i)
											(.apply func (nil) arguments)))
				 ((< ln 11) (lambda (a b c d e f g h i j)
											(.apply func (nil) arguments)))
				 ((< ln 12) (lambda (a b c d e f g h i j k)
											(.apply func (nil) arguments)))
				 ((< ln 13) (lambda (a b c d e f g h i j k l)
											(.apply func (nil) arguments)))
				 ((< ln 14) (lambda (a b c d e f g h i j k l m)
											(.apply func (nil) arguments)))
				 ((< ln 15) (lambda (a b c d e f g h i j k l m n)
											(.apply func (nil) arguments)))
				 ((< ln 16) (lambda (a b c d e f g h i j k l m n o)
											(.apply func (nil) arguments)))
				 :else func)))

(defun *curry (args func)
	(defvar flen (length func))
	(set-arity flen (lambda (...rest)
		(defvar param (.concat args rest))
	  (cond ((< (length param) flen) (*curry param func))
					:else (.apply func (nil) param)))))

(provide
 (defun curry (func)
	 (cond ((< (length func) 1) func)
				 :else (*curry (list) func))))

(provide
 (defun compl (fn ...fns)
	 (curry (set-arity (length fn)
										 (lambda (...rest)
											 (.reduce fns
																(lambda (retv next)
																	(next retv))
																(.apply fn (nil) rest)))))))

(provide
 (defun compr (...fns)
	 (defvar fn (last fns))
	 (assign fns (.slice fns 0 -1))
	 (curry (set-arity (length fn)
										 (lambda (...rest)
											 (.reduce-right fns
																(lambda (retv next)
																	(next retv))
																(.apply fn (nil) rest)))))))

;; --- TYPES
(provide
 (defsum maybe (none) (some value)))

(provide
 (defun maybe-of (value)
	 (maybe.some value)))

(provide
 (defun maybe-lift (value)
	 (cond ((nothing? value) (maybe.none))
				 :else (maybe.some value))))

(defmethod maybe is-some ()
	(defined? (get this 'value)))

(defmethod maybe bimap (none-fn some-fn)
	(cond ((.is-some this) (maybe.some (some-fn this.value)))
				:else (maybe-lift (none-fn))))

(defmethod maybe map (func)
	(.bimap this identity func))

(defmethod maybe concat (maybe-t)
	(cond ((and (.is-some this) (.is-some maybe-t))
				 (maybe.some (.concat this.value maybe-t.value)))
				:else (maybe.none)))

(defmethod maybe ap (maybe-t)
	(cond ((and (.is-some this) (.is-some maybe-t))
				 (.map maybe-t this.value))
				:else (maybe.none)))



(provide
 (defconstant map (curry (lambda (func functor)
													 (cond ((nothing? functor)
																	(error! "Cannot (map) over null/undefined/NaN"))
																 ((lambda? functor.map)
																	(.map functor func))
																 ((future? functor)
																	(.then functor func))
																 ((function? functor)
																	(set-arity (length functor)
																						 (lambda (...args)
																							 (call func (.apply functor (nil) args)))))
																 :else (error! "Value " functor " cannot be (map)ped."))))))
