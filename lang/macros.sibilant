;;;; Sibilisp Macros
;;;; ===============

(namespace sibilisp)
(import-namespace core)



(delete-macro last)
(macro last (ls)
       `(get @ls (- (length @ls) 1)))



;;; ====== OPERATORS ======
(macro eq? (a b)
       ; use loose == operator
       [(transpile a) " == " (transpile b)])

(macro eqv? (a b)
       ; use strict == operator
       [(transpile a) " === " (transpile b)])



;;; LANGUAGE
(macro gensym (a)
       ; generates a generic symbol
       `(generate-symbol @(or a "gensym")))


(macro scoped* (...body)
			 `(*scoped-without-return ...@body))


(macro error! (...msg)
			 `(*scoped-without-return
				 (throw (new Error (+ "" ...@msg)))))

(macro defconstant (...pairs)
       ; allow ES2015 constant definitions
       (as-statement ["const "
                     (pipe pairs
                           destructure
                           (map
                            (lambda (p) [(first p) " = " (second p)]))
                           (interleave ";\nconst "))
                     ]))

(macro defvar (...pairs)
       ; allow ES2015 let definitions
       (as-statement ["let "
                     (pipe pairs
                           destructure
                           (map
                            (lambda (p) [(first p) " = " (second p)]))
                           (interleave ",\n    "))
                     ]))

(macro defun (name args ...body)
       ; function creation utility
       `(defconstant @name (lambda @args ...@body)))

(macro defprop (target ...pairs)
       (var ps (bulk-map pairs
                         (lambda (l r)
                           `(hash @l (hash enumerable true
                                           writable false
                                           configurable false
                                           value @r)))))
       `(.define-properties Object @target @(.reduce ps
                                                     (lambda (acc p)
                                                       (.assign Object acc p))
                                                     (hash))))

;;; ====== CLASSES ======
(delete-macro instance-of?)
(macro instance-of? (item type)
       [(transpile item) " instanceof " (transpile type)])

(macro deftype (tname pkeys)
       (var self (gensym "self")
            type (transpile tname)
            args (interleave ", " pkeys.contents))
       `(defconstant @tname @{ type 'output
             contents [
             "function " type "(" args ") {"
             (indent
              `(do
                (var @self (.create Object (get @type 'prototype)))
                ...@(map pkeys.contents
                         (lambda (p)
                           `(set @self (quote @p) @p)))
                @self))
             "}"]}))

;; (defsum maybe ((none) (some value)))
(macro defsum (tname variants)
			 (var tself (gensym "sumtype")
						subctors (map variants.contents
													(lambda (vartype)
														(var self (gensym "self")
																 type (transpile (first vartype.contents))
																 pkeys undefined
																 args "")
														(when (> (length vartype.contents) 1)
															(assign pkeys (rest vartype.contents))
															(assign args (interleave ", " pkeys)))
														(hash type 'output
																	contents [
																	 "function " type "(" args ") {"
																	 (indent
																		`(do
																			(var @self (.create Object (get @tself 'prototype)))
																			...@(if (defined? pkeys) (map pkeys
																																		(lambda (p)
																																			`(set @self (quote @p) @p)))
																							(list))
																			(set @self 'constructor @type)
																			@self))
																	 "}"])))
						subnames (map variants.contents
													(lambda (vartype) (first vartype.contents))))
			 `(defconstant @tname
					(scoped
					 (defconstant @tself (.create Object (nil)))
					 (set @tself 'prototype (hash))
					 ...@(map subnames
										(lambda (sname index)
											(list `(set @tself (quote @sname) @(get subctors index))
														"\n"
														`(set (get @tself (quote @sname) 'prototype)
																	'**sibilisp-type**
																	@tself))))
					 (defstatic @tself is (x)
											(and (not (eq? () x))
													 (= (get x '**sibilisp-type**)
															@tself)))
					 @tself)))

(macro defstatic (tname mname args ...body)
			 `(set @tname (quote @mname) (lambda (...@args.contents) ...@body)))

(macro defmethod (tname mname args ...body)
       `(defstatic (get @tname 'prototype) @mname @args ...@body))



;;; ====== ES2015+ MODULE SYSTEM ======
(macro use (path ...as)
       ["import { "
       (pipe as
             (map
              (lambda (a)
                (if (= "(" a.token)
                    [(first a.contents) " as " (last a.contents)]
                    a)))
             (interleave ", "))
       " } from " path])

(macro use-all (path alias alias-b)
       ["import "
       (if (and (node? alias) (= 'as alias.token))
           ["* as " alias-b]
           alias) " from " path])



(macro provide (a)
       ["export " (transpile a)])

(macro provide-all (...as)
       (as-statement
        ["export default {\n  "
        (pipe as
              (map
               (lambda (a)
                 (if (= "(" a.token)
                     [(last a.contents) ": " (first a.contents)]
                     [a ": " a])))
              (interleave ",\n  "))
        "\n}"]))


;;; ====== CONDITIONALS ======
(macro cond (...branches)
       ; contitionals. transpiles to a sequence of ternary operators
       (var in-else false)
       (map branches
            (lambda (a)
              (if (and (= "(" a.token) (not in-else))
									(list
									 (first a.contents) "\n  ? "
									 (second a.contents) "\n  : ")
                  (= "else" a.token)
                  (do (assign in-else true)
                      (list))
                  (transpile a)))))

(macro if* (...conditions-and-branches)
			 (interleave " else "
									 (bulk-map conditions-and-branches
														 (lambda (condition branch)
															 (cond ((defined? branch)
																			(list "if (" (transpile condition) ") {"
																						(indent
																						 (transpile branch))
																						"}"))
																		 :else (list "{ " (indent
																											 (transpile condition)) " }"))))))


;; ====== LOOPS ======
(macro while* (condition ...body)
			 (hash type 'output
						 contents (list "while (" (transpile condition) ") {"
														...(map body (lambda (x) (indent (transpile x))))
														"}")))

(macro unless* (condition ...body)
			 `(while* (not @condition) ...@body))

(macro for (coll iter ...body)
			 `(scoped
				 @(hash type 'output
								contents (list "for (let " (transpile iter) " of " (transpile coll)") {"
															 (indent (apply ^do @body))
															 "}"))))

(macro for* (coll iter ...body)
			 (hash type 'output
						 contents (list "for (let " (transpile iter) " of " (transpile coll)") {"
														...(map body (lambda (x) (indent (transpile x))))
														"}")))

(macro break ()
			 (as-statement `break))

(macro continue ()
			 (as-statement `continue))



;;; ====== MATHS ======

(macro floor (a)
			 `(.floor Math @a))

(macro ceil (a)
			 `(.ceil Math @a))

(macro round (a)
			 `(.round Math @a))

(macro sin (a)
			 `(.sin Math @a))

(macro cosin (a)
			 `(.cos Math @a))

(macro tan (a)
			 `(.tan Math @a))

(macro atan (a)
			 `(.atan Math @a))

(macro atan-2 (a b)
			 `(.atan2 Math @b @a))

(macro atanh (a)
			 `(.atanh Math @a))

(macro acos (a)
			 `(.acos Math @a))

(macro acosh (a)
			 `(.acosh Math @a))

(macro asin (a)
			 `(.asin Math @a))

(macro asinh (a)
			 `(.asinh Math @a))

(macro square-root (a)
			 `(.sqrt Math @a))

(macro cube-root (a)
			 `(.cbrt Math @a))

(macro exponent (a)
			 `(.exp Math @a))

(macro min (a b)
			 `(.min Math @a @b))

(macro max (a b)
			 `(.max Math @a @b))

(macro round (a)
			 `(* (.round Math) @(or a 1)))

(macro abs (a)
			 `(.abs Math @a))



;;; ====== TYPES ======



(macro is-a (a ctor)
       ; machtes a value agains a given type constructor
       `(and (not (eq? () @a))
						 (not (isNaN @a))
             (eqv? (get @a 'constructor) @ctor)))




(macro void ()
       ; transpiles to undefined
       ["void 0"])

(macro void? (...values)
			 `(and ...@(map values
											(lambda (v) `(undefined? @v)))))

(macro nil ()
       ; equivalent of null
       `())

(macro nil? (...values)
       `(and ...@(map values (lambda (v)
                               `(eqv? @v (nil))))))

(macro nan ()
			 `NaN)

(macro nan? (...values)
       ; checks multiple values for equality with NaN
       `(and ...@(map values (lambda (v)
                               `(and (= (typeof @v) 'number)
                                     (isNaN @v))))))

(macro nothing? (...values)
       ; checks multiple values for equality with null or undefined
       `(and ...@(map values (lambda (v)
                               `(or (eq? null @v)
                                    (nan? @v))))))


(delete-macro number?)
(macro number? (...values)
       ; tests if given values are numbers and not NaN
       `(and ...@(map values (lambda (v)
                               `(and (eqv? (typeof @v) "number")
                                     (not (nan? @v)))))))



(delete-macro list?)
(macro list? (...values)
       ; make better list? macro than core sibilant provides
       `(and ...@(map values (lambda (v)
                               `(.isArray Array @v)))))

(macro as-list (value)
			 `(.from Array @value))



(delete-macro hash?)
(macro hash? (...values)
       ; tests if given values are objects
       `(and ...@(map values (lambda (v)
                               `(is-a @v Object)))))

(macro hash-pairs (value)
			 `(.entries Object @value))

(macro hash-merge (...values)
			 `(.assign Object (hash) ...@values))

(macro hash-create (value)
			 `(.create Object @value))



(macro date (...args)
       ; creates new Date objects
       `(new Date ...@args))

(macro date? (...values)
       ; tests if given values are dates
       `(and ...@(map values (lambda (v)
                               `(is-a @v Date)))))

(macro date-now-utc ()
			 `(.now Date))

(macro date-now ()
			 `(as-number (new Date)))

(macro date-parse (iso-string)
			 `(.parse Date @iso-string))



(macro regex (pattern flag)
			 `(new RegExp @pattern @flag))

(macro regex? (...values)
       ; tests if given values are regular expressions
       `(and ...@(map values (lambda (v)
                               `(is-a @v RegExp)))))



(macro future (cbs ...body)
       ; creates Promise objects
       `(new Promise (lambda (@(interleave ", " cbs.contents))
                       ...@body)))

(macro future? (...values)
       ; tests if given values are promises
       `(and ...@(map values (lambda (v)
                               `(is-a @v Promise)))))

(macro future-resolve (value)
			 `(.resolve Promise @value))

(macro future-reject (err)
			 `(.reject Promise @err))

(macro future-all (...futures)
			 `(.all Promise (list ...@futures)))

(macro future-any (...futures)
			 `(.race Promise (list ...@futures)))



(macro dict (...key-vals)
       ; creates Map objects
       (var kvs (bulk-map key-vals
                          (lambda (key val)
                            `(list key val))))
       `(new Map (list ...@kvs)))

(macro dict? (...values)
       ; tests if given values are maps
       `(and ...@(map values (lambda (v)
                               `(is-a @v Map)))))




;; NOTE
;; we won't support the native Set datatype. that is by
;; intention, because Sets in JavaScript are more or
;; less useless, except for creating a union



(macro generator (name args ...body)
			 (hash type 'output
						 contents (list "function * " (transpile name) "("
														(interleave ", " args.contents)
														") {"
														...(map body (lambda (expr)
																					 (indent (transpile expr))))
														"}")))

(macro yields (value)
			 (as-statement (list "yield " @(transpile value))))



;; ====== RECURSION ======
(macro trampoline-fn (name args ...body)
       ["function " name
       "(" (interleave ", " args.contents)  ") {"
       (indent (apply ^do body))
       "}"])

(macro trampoline-is (a)
       `(and (function? @a)
             (get @a '**sibilisp-recur**)))

(macro recur (...args)
       ; creates a new jump point if the fixpoint is not reached
       (var jump (gensym "jump"))
       `(scoped
         (defun @jump () (call looprec-step ...@args))
         (defprop @jump '**sibilisp-recur** true)))

(macro loop (variables ...body)
       ; allows to use single and multiple direct recursion
       ; through trampolining. performance is generally ok
       ; up to and above 7500 iterations, which should be
       ; good enough for most use cases.
       (var retv (gensym "looprecReturn")
            vars (map variables.contents
                      (lambda (pair) (first pair.contents)))
            vals (map variables.contents
                      (lambda (pair) (last pair.contents))))
       `(scoped
         (call
          (lambda (step ...args)
            (var @retv (.apply step (nil) args))
            (while* (trampoline-is @retv)
              (assign @retv (call @retv)))
            @retv)
          (trampoline-fn looprec-step (...@vars) ...@body)
          ...@vals)))
