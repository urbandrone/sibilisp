;;;; Sibilisp Macros
;;;; ===============

(namespace sibilisp)
(import-namespace core)



(delete-macro last)
(macro last (ls)
       `(get @ls (- (length @ls) 1))) ; slightly faster than original



;;; ====== OPERATORS ======
(macro eq? (a b)
       ; use loose == operator
       [(transpile a) " == " (transpile b)])

(macro eql? (a b)
       ; use strict == operator
       [(transpile a) " === " (transpile b)])



(macro setf (x ...ps-vl)
       ; allows setting a nested propertie's value
       (var val (last ps-vl)
              keys (.slice ps-vl 0 -1)
              key (.pop keys))
       `(set (get @x ...@keys) @key @val))

(macro getf (x ...ps)
       ; just an alias to sibilant's (get) for symmetry with our (setf)
       `(get @x ...@ps))



;;; LANGUAGE
(macro gensym (a)
       ; generates a generic symbol
       `(generate-symbol @(or a "gensym")))



(macro error (...msg)
       ; creates new error instances
       `(new Error (+ "" ...@msg)))

(macro error! (...msg)
       ; creates and immediatly throws a new error instance
       `(*scoped-without-return
         (throw (error ...@msg))))

(macro error? (...values)
       ; checks multiple values for being instances of errors
       `(and ...@(map values (lambda (v)
                               `(.is-prototype-of (get Error 'prototype) @v)))))


(macro defconstant (...pairs)
       ; allow ES2015 constant definitions
       (as-statement ["const "
                      (pipe pairs
                            destructure
                            (map
                             (lambda (p) [(first p) " = " (second p)]))
                            (interleave ";\nconst "))]))
                     

(macro defvar (...pairs)
       ; allow ES2015 let definitions
       (as-statement ["let "
                      (pipe pairs
                            destructure
                            (map
                             (lambda (p) [(first p) " = " (second p)]))
                            (interleave ",\n    "))]))
                     

(macro let (var-lists ...body)
       ; idiomatic variables
       (var vnames (map var-lists.contents (lambda (c) (first (get c 'contents))))
            vvals (map var-lists.contents (lambda (c) (last (get c 'contents)))))
       `(call (lambda (...@vnames) ...@body) ...@vvals))

(macro let* (var-lists ...body)
       ; idiomatic variables with back referencing
       (var vars (map var-lists.contents
                      (lambda (paired)
                        `(defvar ...@paired.contents))))
       `(scoped
         ...@vars
         (call (lambda () ...@body))))

(macro defun (name args ...body)
       ; function creation utility
       `(defconstant @name (lambda @args ...@body)))

(macro defprop (target ...pairs)
       (var ps (bulk-map pairs
                         (lambda (l r)
                           `(hash @l (hash enumerable true
                                           writable false
                                           configurable false
                                           value @r)))))
       `(.define-properties Object @target @(.reduce ps
                                                     (lambda (acc p)
                                                       (.assign Object acc p))
                                                     (hash))))

;;; ====== CLASSES ======
(delete-macro instance-of?)
(macro instance-of? (item type)
       ; fix broken instance-of macro
       [(transpile item) " instanceof " (transpile type)])

(macro deftype (tname pkeys)
       ; tagged type constructor creation facility
       (var self (gensym "self")
            type (transpile tname)
            args (interleave ", " pkeys.contents)
            alen (length pkeys.contents))
       `(defconstant @tname @{ type 'output
                              contents [
                                        "function " type "(" args ") {"
                                        (indent
                                         `(do
                                           (defvar @self (.create Object (get @type 'prototype)))
                                           (defvar alen (length arguments))
                                           (when (not (eql? alen @alen))
                                             (error! "Tagged constructor " @tname
                                                     "expects " @alen " arguments but got "
                                                     alen))
                                           ...@(map pkeys.contents
                                                    (lambda (p)
                                                      `(set @self (quote @p) @p)))
                                           @self))
                                        "}"]}))

(macro defsum (tname variants)
       ; tagged sum type creation facility
       (var tself (gensym "sumtype")
            subctors (map variants.contents
                          (lambda (vartype)
                            (var self (gensym "self")
                                 type (transpile (first vartype.contents))
                                 pkeys undefined
                                 alen 0
                                 args "")
                            (when (> (length vartype.contents) 1)
                              (assign pkeys (rest vartype.contents))
                              (assign alen (length pkeys))
                              (assign args (interleave ", " pkeys)))
                            (hash type 'output
                                  contents [
                                            "function " type "(" args ") {"
                                            (indent
                                             `(do
                                               (defvar @self (.create Object (get @tself 'prototype)))
                                               (defvar alen (length arguments))
                                               (when (not (eql? alen @alen))
                                                 (error! "Tagged constructor " @tname "." @type
                                                         "expects " @alen " arguments but got "
                                                         alen))
                                               ...@(if (defined? pkeys) (map pkeys
                                                                             (lambda (p)
                                                                               `(set @self (quote @p) @p)))
                                                       (list))
                                               (set @self 'constructor @type)
                                               (set @self '**sibilisp-tags** (list ...@(map pkeys (lambda (k) `(quote @k)))))
                                               @self))
                                            "}"])))
            subnames (map variants.contents
                          (lambda (vartype) (first vartype.contents))))
       `(defconstant @tname
          (scoped
           (defconstant @tself (.create Object (nil)))
           (set @tself 'prototype (hash **sibilisp-type** @tself))
           ...@(map subnames
                    (lambda (sname index)
                      (list `(set @tself (quote @sname) @(get subctors index)))))
           (set (get @tself 'prototype) 'match (lambda (ctors)
                                                  (defvar self this
                                                          name (get self 'constructor 'name)
                                                          ctor (get ctors name)
                                                          keys (get self '**sibilisp-tags**))
                                                  (if (function? ctor)
                                                      (.apply ctor
                                                              self
                                                              (.map keys (lambda (key)
                                                                           (get self key))))
                                                      (error! ".match :: Cannot find "
                                                              name
                                                              " in patterns "
                                                              ctors))))
                                                        
           (set @tself 'is (lambda (x)
                            (and (not (eq? () x))
                                 (= (get x '**sibilisp-type**)
                                    @tself))))
           @tself)))

(macro defmethod (tname mname args ...body)
       ; method definition facility for types and sum types
       `(set (get @tname 'prototype) (quote @mname) (lambda @args ...@body)))

(macro method? (tname mname)
       ;
       `(function? (get @tname (quote @mname))))



;;; ====== ES2015+ MODULE SYSTEM ======
(macro use (path ...as)
       ; imports named module exports
       ["import { "
        (pipe as
              (map
               (lambda (a)
                 (if (= "(" a.token)
                     [(first a.contents) " as " (last a.contents)]
                     a)))
              (interleave ", "))
        " } from " path])

(macro use-all (path alias alias-b)
       ; imports whole modules
       ["import "
        (if (and (node? alias) (= 'as alias.token))
            ["* as " alias-b]
            alias) " from " path])



(macro provide (a)
       ; creates named exports
       ["export " (transpile a)])

(macro provide-all (...as)
       ; creates default exports
       (as-statement
        ["export default {\n  "
         (pipe as
               (map
                (lambda (a)
                  (if (= "(" a.token)
                      [(last a.contents) ": " (first a.contents)]
                      [a ": " a])))
               (interleave ",\n  "))
         "\n}"]))


;;; ====== CONDITIONALS ======
(macro cond (...branches)
       ; contitionals. transpiles to a sequence of ternary operators
       (var in-else false)
       `(parens
          @(map branches
            (lambda (a)
              (if (and (= "(" a.token) (not in-else))
                  (list
                   (first a.contents) "\n  ? "
                   (second a.contents) "\n  : ")
                  (= "else" a.token)
                  (do (assign in-else true)
                      (list))
                  (transpile a))))))

(macro if* (...conditions-and-branches)
       (interleave " else "
                   (bulk-map conditions-and-branches
                             (lambda (condition branch)
                               (cond ((defined? branch)
                                      (list "if (" (transpile condition) ") {"
                                            (indent
                                             (transpile branch))
                                            "}"))
                                     :else (list "{ " (indent
                                                       (transpile condition)) " }"))))))


;; ====== LOOPS ======
(macro while* (condition ...body)
       (hash type 'output
             contents (list "while (" (transpile condition) ") {"
                            ...(map body (lambda (x) (indent (transpile x))))
                            "}")))

(macro unless* (condition ...body)
       `(while* (not @condition) ...@body))

(macro for (coll iter ...body)
       `(scoped
         @(hash type 'output
                contents (list "for (let " (transpile iter) " of " (transpile coll)") {"
                               (indent (apply ^do @body))
                               "}"))))

(macro for* (coll iter ...body)
       (hash type 'output
             contents (list "for (let " (transpile iter) " of " (transpile coll)") {"
                            ...(map body (lambda (x) (indent (transpile x))))
                            "}")))

(macro break ()
       (as-statement `break))

(macro continue ()
       (as-statement `continue))






;;; ====== TIME ======
(macro timeout (ms ...body)
       `(set-timeout (lambda () ...@body) @ms))

(macro interval (ms ...body)
       `(set-interval (lambda () ...@body) @ms))



;;; ====== ARITHMETIC ======
(macro op-exponentiation (...values)
       (list "(" (interleave " ** " values) ")"))
(alias-macro ap-exponentiation **)




;;; ====== MATHS ======

(macro floor (a)
       `(.floor Math @a))

(macro ceil (a)
       `(.ceil Math @a))

(macro round (a)
       `(.round Math @a))

(macro sine (a)
       `(.sin Math @a))

(macro cosine (a)
       `(.cos Math @a))

(macro tan (a)
       `(.tan Math @a))

(macro atan (a)
       `(.atan Math @a))

(macro atan-2 (a b)
       `(.atan2 Math @b @a))

(macro atan-h (a)
       `(.atanh Math @a))

(macro acos (a)
       `(.acos Math @a))

(macro acos-h (a)
       `(.acosh Math @a))

(macro asine (a)
       `(.asin Math @a))

(macro asine-h (a)
       `(.asinh Math @a))

(macro square-root (a)
       `(.sqrt Math @a))

(macro cube-root (a)
       `(.cbrt Math @a))

(macro exp (a)
       `(.exp Math @a))

(macro exp-m1 (a)
       `(.expm1 Math @a))

(macro min (a b)
       `(.min Math @a @b))

(macro max (a b)
       `(.max Math @a @b))

(macro random (a)
       `(* (.random Math) @(or a 1)))

(macro float32-round (a)
       `(.fround Math @a))

(macro power (a p)
       `(.pow Math @a @p))

(macro hypot (a b)
       `(.hypot Math @a @b))

(macro loga (a)
       `(.log Math @a))

(macro loga-10 (a)
       `(.log10 Math @a))

(macro loga-1p (a)
       `(.log1p Math @a))

(macro loga-2 (a)
       `(.log2 Math @a))

(macro abs (a)
       `(.abs Math @a))

(macro sign (a)
       `(.sign Math @a))

(macro trunc (a)
       `(.trunc Math @a))


(macro PI ()
       `(get Math 'PI))

(macro EULER ()
       `(get Math 'E))





;;; ====== TYPES ======

(macro void ()
       ; transpiles to undefined
       ["void 0"])

(macro void? (...values)
       ; checks for equality with undefined
       `(and ...@(map values
                      (lambda (v) `(undefined? @v)))))

(macro nil ()
       ; equivalent of null
       `())

(macro nil? (...values)
       ; checks for equality with null
       `(and ...@(map values (lambda (v)
                               `(eql? @v (nil))))))

(delete-macro exists?)
(macro exists? (...values)
       ; core sibilant exists? macro is a bit verbose in it's output
       `(and ...@(map values (lambda (v)
                               `(not (eq? @v (nil)))))))

(macro nan ()
       `NaN)

(macro nan? (...values)
       ; checks multiple values for equality with NaN
       `(and ...@(map values (lambda (v)
                               `(.isNaN Number @v)))))

(macro is-a (a ctor)
       ; machtes a value agains a given type constructor
       `(and (not (eq? () @a))
             (eql? (get @a 'constructor) @ctor)))

(macro finite? (...values)
       ; checks multiple values for being numeric and finite
       `(and ...@(map values (lambda (v)
                               `(and (eql? (typeof @v) 'number)
                                     (is-finite @v))))))

(macro nothing? (...values)
       ; checks multiple values for equality with null or undefined
       `(and ...@(map values (lambda (v)
                               `(or (eq? null @v)
                                    (nan? @v))))))



(macro as-number (value)
       `(Number @value))

(delete-macro number?)
(macro number? (...values)
       ; tests if given values are numbers and not NaN
       `(and ...@(map values (lambda (v)
                               `(and (eql? (typeof @v) "number")
                                     (not (nan? @v)))))))



(macro as-string (value)
       `(String @value))



(delete-macro list?)
(macro list? (...values)
       ; use native isArray for list? macro
       `(and ...@(map values (lambda (v)
                               `(.isArray Array @v)))))

(macro as-list (value)
       ; creates a list from array-like objects
       `(.from Array @value))



(delete-macro hash?)
(macro hash? (...values)
       ; core sibilants hash? macro enhancements
       `(and ...@(map values (lambda (v)
                               `(is-a @v Object)))))

(macro hash-pairs (value)
       ; creates a list of key/value pairs from objects
       `(.entries Object @value))

(macro hash-merge! (...values)
       ; unsafely merges multiples objects into one
       ; objects to the right override previous objects
       ; ! modifies the left most object !
       `(.assign Object ...@values))

(macro hash-merge (...values)
       ; safely merges multiple objects into a new objects
       ; objects to the right override previous objects
       `(hash-merge! (hash) ...@values))

(macro hash-create (value)
       ; creates new instances of objects
       `(.create Object @value))



(macro date (...args)
       ; creates new Date objects
       `(new Date ...@args))

(macro date? (...values)
       ; tests if given values are dates
       `(and ...@(map values (lambda (v)
                               `(is-a @v Date)))))

(macro date-now-utc ()
       ; returns the milliseconds since begin of the unix epoche
       ; in universal coordinated time
       `(.now Date))

(macro date-now ()
       ; returns the milliseconds since begin of the unix epoche
       ; in local time
       `(as-number (new Date)))

(macro date-parse (iso-string)
       ; uses the native Date.parse method to parse a string
       ; in simplified ISO 8601 format (e. g. 2000-03-03T12:26:37)
       ; returns the milliseconds since begin of the unix epoche
       ; in universal coordinated time
       `(.parse Date @iso-string))



(macro regex (pattern flag)
       ; creates new regular expressions without the need for the new macro
       `(new RegExp @pattern @flag))

(macro regex? (...values)
       ; tests if given values are regular expressions
       `(and ...@(map values (lambda (v)
                               `(is-a @v RegExp)))))



(macro future (cbs ...body)
       ; creates Promise objects
       `(new Promise (lambda (@(interleave ", " cbs.contents))
                       ...@body)))

(macro future? (...values)
       ; tests if given values are promises
       `(and ...@(map values (lambda (v)
                               `(is-a @v Promise)))))

(macro future-resolve (value)
       ; creates a resolving promise
       `(.resolve Promise @value))

(macro future-reject (err)
       ; creates a rejecting promise
       `(.reject Promise @err))

(macro future-all (...futures)
       ; creates a single promise from multiple promises that
       ; resolves when all promises resolve or rejects if any
       ; promise rejects
       `(.all Promise (list ...@futures)))

(macro future-any (...futures)
       ; creates a single promise from multiple promises that
       ; resolves with the first resolving promise or rejects
       ; when any promise rejects
       `(.race Promise (list ...@futures)))



(macro dict (...key-vals)
       ; creates Map objects
       (var kvs (bulk-map key-vals
                          (lambda (key val)
                            `(list key val))))
       `(new Map (list ...@kvs)))

(macro dict? (...values)
       ; tests if given values are maps
       `(and ...@(map values (lambda (v)
                               `(is-a @v Map)))))

(macro dict-pairs (value)
       ; transforms a map into a list of pairs
       `(as-list (.entries @value)))

(macro dict-values (value)
       ; transforms a map into a list of values
       `(as-list (.values @value)))

(macro dict-merge! (...values)
       (var fst (first values)
            rst (rest values)
            d (gensym "dict")
            k (gensym "dictKey")
            v (gensym "dictVal"))
       `(scoped
         (each @d @rst
               (each (@v @k) @d
                     (.set @fst @k @v)))
         @fst))

(macro dict-merge (...values)
       `(dict-merge! (dict) ...values))



;; --- union/mset
(macro mset (...values)
       `(new Set (list ...@values)))

(macro mset? (...values)
       `(and ...@(map values
                      (lambda (v)
                        `(is-a @v Set)))))

(macro mset-pairs (value)
       `(as-list (.entries @value)))

(macro mset-values (value)
       `(as-list (.values @value)))

(macro mset-merge! (...values)
       (var fst (first values)
            rst (rest values)
            d (gensym "mset")
            v (gensym "msetVal"))
       `(scoped
         (each @d @rst
               (each @v @d
                     (.add @fst @v)))
         @fst))

(macro mset-merge (...values)
       `(mset-merge! (mset) ...@values))     



(macro generator (name args ...body)
       ; creates ES2015+ generator functions
       (hash type 'output
             contents (list "function * " (transpile name) "("
                            (interleave ", " args.contents)
                            ") {"
                            ...(map body (lambda (expr)
                                           (indent (transpile expr))))
                            "}")))

(macro generator? (...values)
       `(and ...@(map values
                      (lambda (v)
                            `(is-a @v GeneratorFunction)))))

(macro yields (value)
       ; creates a yield statement for use in generator functions
       (as-statement (list "yield " (transpile value))))

(macro yields-values (value)
       ; creates a yield* statement for use in generator functions
       (as-statement (list "yield* " (transpile value))))



;; ====== JSON ======
(macro json-from-string (value)
       ; parses a JSON string into an object
       `(.parse JSON @value))

(macro json-to-string (value)
       ; parses an object into a JSON string
       `(.stringify JSON @value))



;; ====== RECURSION ======
(macro trampoline-fn (name args ...body) ; used internally
       ["function " name
        "(" (interleave ", " args.contents)  ") {"
        (indent (apply ^do body))
        "}"])

(macro trampoline-is (a) ; used internally
       `(and (function? @a)
             (get @a '**sibilisp-recur**)))

(macro recur (...args)
       ; creates a new jump point if the fixpoint is not reached
       (var jump (gensym "jump"))
       `(scoped
         (defun @jump () (call looprec-step ...@args))
         (defprop @jump '**sibilisp-recur** true)))

(macro loop (variables ...body)
       ; allows to use single and multiple direct recursion
       ; through trampolining. performance is generally ok
       ; up to and above 7500 iterations, which should be
       ; good enough for most use cases.
       (var retv (gensym "looprecReturn")
            vars (map variables.contents
                      (lambda (pair) (first pair.contents)))
            vals (map variables.contents
                      (lambda (pair) (last pair.contents))))
       `(scoped
         (call
          (lambda (step ...args)
            (var @retv (.apply step (nil) args))
            (while* (trampoline-is @retv)
              (assign @retv (call @retv)))
            @retv)
          (trampoline-fn looprec-step (...@vars) ...@body)
          ...@vals)))
