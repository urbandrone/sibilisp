(comment sibilisp-prelude - MIT)

;;; BASIC LAMBDA OPERATORS (I, K, S)
(provide
 (defun identity (a) a))

(provide
 (defun thunk (a)
   (lambda () a)))


;;; LANGUAGE TYPE CHECK UTILITIES
(provide
  (defun list-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(list-of? expects argument 2 to
					 				 be a function, got " predicate))
          :else (and (list? x)
                     (.every x predicate)))))

(provide
  (defun hash-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(hash-of? expects argument 2 to 
					 				 be a function, got " predicate))
          :else (and (hash? x)
                     (.every (hash-pairs x) (lambda ([_ v]) (predicate v)))))))

(provide 
  (defun dict-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(dict-of?) expects argument 2 to 
					 				 be a function, got " predicate))
          :else (and (dict? x)
                     (.every (.entries x) (lambda ([_ v]) (predicate v)))))))



;;; FUNCTION FUNCTIONS
(provide
  (defun converge (combine branches)
    (cond ((not (function? combine))
           (error! "(converge) expects argument 1 to
					 				 be a function, got " combine))
          ((not (list-of? branches (lambda (v) (function? v))))
           (error! "(converge) expects argument 2 to
					 				 be a list of functions, got " branches))
          :else (lambda (...args)
                  (cond ((not (= (length args) (length branches)))
                         (error! "(converge -> lambda) expects arguments
												 				 length (" (length args) ") to equal the number
																 of branches (" (length branches) ") but they
																 differ."))
                        :else (.apply converge
                                      (nil)
                                      (.map branches
                                            (lambda (branch i)
                                              (branch (get args i)
                                                      i
                                                      args)))))))))



;;; ALGEBRAIC TYPES

;; --- coyo (-neda)
(provide
  (deftype coyo (value mapper)))

(defmethod coyo to-string ()
  (let ((value (get this 'value))
        (fn (get this 'mapper)))
    (+ "(coyo " (show value) " " (show fn) ")")))

(defmethod coyo map (mapper)
  (cond ((not (function? mapper))
         (error! "(coyo.map) expects argument 1 to be
                 a function, got " (show mapper)))
        :else (let ((value (get this 'value))
                    (run-self (get this 'mapper)))
                (coyo value (lambda (arg) (mapper (run-self arg)))))))

(defmethod coyo lower ()
  (let ((mapper (get this 'mapper))
        (value (get this 'value)))
    (cond ((not (function? mapper))
           (error! "(coyo.lower) requires the coyo:mapper property
                   to hold a function, but it holds " (show mapper)))
          ((not (exists? value))
           (error! "(coyo.lower) requires the coyo:value property
                   to hold a non (void) or (nil) value, but it holds "
                   (show value)))
          ((not (function? (get value 'map)))
           (error! "(coyo.lower) requires the coyo:value property
                   to implement the functor typeclass but it doesn't"))
          :else (coyo (.map value mapper) identity))))

(defmethod coyo get-value ()
  (call (get this 'mapper) (get this 'value)))


;; --- io
(provide
  (deftype io (unsafe-perform)))

(defmethod io to-string ()
  (let ((fn (get this 'unsafe-perform)))
    (+ "(io " (show fn) ")")))

(defmethod io equals (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.equals) expects argument 1 to be
                 an io, got " (show t-io)))
        :else (eql? (get this 'unsafe-perform)
                    (get t-io 'unsafe-perform))))

(defmethod io concat (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.concat) expects argument 1 to be
                 an io, got " (show t-io)))
        :else (let ((run-self (get this 'unsafe-perform))
                    (run-that (get t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (run-that
                        (run-self arg)))))))

(defmethod io map (mapper)
  (cond ((not (function? mapper))
         (error! "(io.map) expects argument 1 to be
                 a function, got " (show mapper)))
        :else (let ((run-self (get this 'unsafe-perform)))
                (io (lambda (arg)
                      (mapper (run-self arg)))))))

(defmethod io ap (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.ap) expects argument 1 to be
                 an io, got " (show t-io)))
        :else (let ((run-self (get this 'unsafe-perform))
                    (run-that (get t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (call (run-self run-that) arg))))))

(defmethod io flat-map (to-io-mapper)
  (cond ((not (function? to-io-mapper))
         (error! "(io.flat-map | io.chain) expects argument 1 to be
                 an io returning function, got " (show to-io-mapper)))
        :else (let ((run-self (get this 'unsafe-perform)))
                (io (lambda (arg)
                      (.unsafe-perform (to-io-mapper (run-self arg)) arg))))))

(set (get io 'prototype) 'chain (get io 'prototype 'flat-map))

(defmethod io compose (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.compose) expects argument 1 to be
                 an io, got " (show t-io)))
        :else (let ((run-self (get this 'unsafe-perform))
                    (run-that (get t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (run-that
                        (run-self arg)))))))

(defmethod io run-io (arg)
  (.unsafe-perform this arg))


(provide
  (defun io-of (value)
    (io (lambda () value))))

(provide
  (defun io-empty ()
    (io identity)))

(provide
  (defun io-identity ()
    (io identity)))


;; --- maybe
(provide
  (defsum maybe ((nothing) (just value))))

(defmethod maybe to-string ()
  (.match this (hash nothing (lambda () 
                               "(maybe.nothing)")
                     just (lambda (value)
                            (+ "(maybe.just " (show value) ")")))))

(defmethod maybe equals (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.equals) expects argument 1 to be
            an instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda ()
                          (.match t-maybe
                                  (hash nothing (lambda () true)
                                        just (lambda () false))))
                just (lambda (value)
                      (.match t-maybe 
                              (hash nothing (lambda ()
                                              false)
                                    just (lambda (t-value)
                                           (if (function? (get value 'equals))  
                                               (.equals value t-value)
                                               (eql? value t-value)))))))))

(defmethod maybe concat (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.concat) expects argument 1 to be
            an instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda ()
                          (maybe.nothing))
                just (lambda (value)
                       (.match t-maybe
                               (hash nothing (lambda () t-maybe)
                                     just (lambda (t-value)
                                            (let ((cnt (get value 'concat)))
                                              (when (not (function? cnt))
                                                (error! "(maybe.concat) cannot
                                                        concat when both of
                                                        the carried values
                                                        implement the
                                                        semigroup
                                                        typeclass"))
                                              (.call cnt value t-value)))))))))

(defmethod maybe map (mapper)
  (cond ((not (function? mapper))
         (error! "(maybe.map) expects argument 1 to be
                 a function, got " (show mapper)))
        :else (.match this 
                      (hash nothing (lambda ()
                                      (maybe.nothing))
                            just (lambda (value) 
                                  (maybe-lift (mapper value))))))) 

(defmethod maybe ap (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! ""))
  (.match this
          (hash nothing (lambda () 
                          (maybe.nothing))
                just (lambda (value)
                      (.map t-maybe value)))))
                      


(provide
  (defun maybe-of (value)
    (maybe.just value)))

(provide
  (defun maybe-empty ()
    (maybe.nothing)))

(provide
  (defun maybe-zero ()
    (maybe.nothing)))

(provide
  (defun maybe-lift (value)
    (cond (exists? value)
          (maybe.just value)
          (maybe.nothing))))


;;; GENERAL PURPOSE OPERATIONS
(provide
  (defun show (x)
    (cond ((eq? (nil) x)
           "(nil)")
          ((nan? x)
           "(nan)")
          ((string? x)
           (+ "(string " x ")"))
          ((number? x)
           (+ "(number " x ")"))
          ((function? x)
           (+ "(function " (or (get x 'name) "lambda") ")"))
          ((generator? x)
           (+ "(generator " (get x 'name) ")"))
          ((list? x)
           (+ "(list" (.reduce x (lambda (a v)
                                   (+ a " " (show v))) "") ")"))
          ((hash? x)
           (+ "(hash" (.reduce (hash-pairs x)
                               (lambda (a [k v])
                                (+ a " :" k " " (show v))) "") ")"))
          ((dict? x)
           (+ "(dict" (.reduce (.entries x)
                               (lambda (a [k v])
                                 (+ a " :" (show k) " " (show v)))
                               "") ")"))
          ((future? x)
           "(future)")
          ((date? x)
           (+ "(date" (.get-full-year x)
              "-" (+ 1 (.get-month x))
              "-" (.get-date x) ")"))
          ((regex? x)
           (+ "(regex " (get x 'source) " :flags " (get x 'flags) ")"))
          :else (.to-string x))))
