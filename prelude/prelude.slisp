(comment sibilisp-prelude - MIT)

;;; CONSTANTS
(defconstant *e-no-value* "E_NO_VALUE")
(defconstant *e-guard* " guards agains (nil) and (void) values, got")
(defconstant *e-arg-1* " expects argument 1 to be a ")
(defconstant *e-arg-2* " expects argument 2 to be a ")
(defconstant *e-arg-3* " expects argument 3 to be a ")

;;; BASIC LAMBDA OPERATORS (I, K, S)
(provide
  ;; identity :: a -> a
  (defun identity (a) a))

(provide
  ;; thunk :: a -> () -> a
  (defun thunk (a)
    (lambda () a)))


;;; LANGUAGE TYPE CHECK UTILITIES
(provide
  ;; list-of? :: (a, (_ -> Boolean)) -> Boolean
  ;; --- (list-of *items* (lambda (x) (string? x)))
  (defun list-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(list-of?)" *e-arg-2* "function, got " predicate))
          :else (and (list? x)
                     (.every x predicate)))))

(provide
  (defun hash-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(hash-of?)" *e-arg-2* "function, got " predicate))
          :else (and (hash? x)
                     (.every (hash-pairs x) (lambda ([_ v]) (predicate v)))))))

(provide 
  (defun dict-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(dict-of?)" *e-arg-2* "function, got " predicate))
          :else (and (dict? x)
                     (.every (.entries x) (lambda ([_ v]) (predicate v)))))))



;;; FUNCTION FUNCTIONS
(provide
  ;; converge :: (((a, b, ...) -> c), [(_ -> a), (_ -> b), ...]) -> ((_, _, ...) -> c)
  (defun converge (combine branches)
    (cond ((not (function? combine))
           (error! "(converge)" *e-arg-1* "function, got " combine))
          ((not (list-of? branches (lambda (v) (function? v))))
           (error! "(converge)" *e-arg-2* "list of functions, got " branches))
          :else (lambda (...args)
                  (cond ((not (= (length args) (length branches)))
                         (error! "(converge -> lambda) expects arguments
												 				 length (" (length args) ") to equal the number
																 of branches (" (length branches) ") but they
																 differ."))
                        :else (.apply combine
                                      (nil)
                                      (.map branches
                                            (lambda (branch i)
                                              (branch (get args i)
                                                      i
                                                      args)))))))))



;;; GENERAL PURPOSE OPERATIONS
(provide
  ;; show :: a -> String
  (defun show (x)
    (cond ((eq? (nil) x)
           "(nil)")
          ((nan? x)
           "(nan)")
          ((string? x)
           (+ "(string " x ")"))
          ((number? x)
           (+ "(number " x ")"))
          ((function? x)
           (+ "(function " (or (get x 'name) "lambda") ")"))
          ((generator? x)
           (+ "(generator " (get x 'name) ")"))
          ((list? x)
           (+ "(list" (.reduce x (lambda (a v)
                                   (+ a " " (show v))) "") ")"))
          ((hash? x)
           (+ "(hash" (.reduce (hash-pairs x)
                               (lambda (a [k v])
                                (+ a " :" k " " (show v))) "") ")"))
          ((dict? x)
           (+ "(dict" (.reduce (.entries x)
                               (lambda (a [k v])
                                 (+ a " :" (show k) " " (show v)))
                               "") ")"))
          ((future? x)
           "(future)")
          ((date? x)
           (+ "(date" (.get-full-year x)
              "-" (+ 1 (.get-month x))
              "-" (.get-date x) ")"))
          ((regex? x)
           (+ "(regex " (get x 'source) " :flags " (get x 'flags) ")"))
          :else (.to-string x))))


(provide
  ;; equals :: (a, b) -> Boolean
  (defun equals (x y)
      (cond ((nil? x) (nil? y))
            ((void? x) (void? y))
            ((string? x y) (eql? x y))
            ((function? x y) (eql? x y))
            ((number? x y) (eql? x y))
            ((regex? x y) (and (eql? (get x 'source
                                                 (get y 'source)
                                           (eql? (get x 'flag)
                                                 (get y 'flag))))))
            ((date? x y) (eql? (as-number x
                                           (as-number y))))
            ((generator? x y) (eql? x y))
            ((future? x y) (eql? x y))
            ((list? x y) (and (eql? (length x
                                                (length y)
                                          (.every 
                                            x
                                            (lambda (va i)
                                              (equals va (get y i))))))))
            ((hash? x y) (let ((pa (hash-pairs x
                                           (pb (hash-pairs y))
                                      (and (eql? (length pa) (length pb))
                                           (.every 
                                            pa
                                            (lambda ([k v])
                                              (equals v (get y k))))))))))
            ((dict? x y) (let ((pa (dict-pairs x
                                           (pb (dict-pairs y))
                                      (and (eql? (length pa) (length pb))
                                           (.every
                                            pa
                                            (lambda ([k v])
                                              (equals v (.get y k))))))))))
            ((function? (get x 'equals)) (.equals x y))
            :else false)))

(provide
  ;; concat :: Semigroup S. (S a, S a) -> S a
  ;; --- string, function, list, future, semigroupoid
  (defun concat (x y)
    (cond ((or (not (exists? x)) (not (exists? y)))
           (error! "(concat) cannot concatenate with a (void) or (nil) value"))
          ((string? x y) (+ x y))
          ((function? x y) (lambda (...args
                                        (y (.apply x null args)))))
          ((list? x y) (.concat x y))
          ((future? x y) (future-all x y))
          ((function? (get x 'concat)) (.concat x y))
          :else (error! "(concat) needs both arguments to be in the same semigroup"))))

(provide
  ;; map :: Functor F. (F a, (a -> b)) -> F b
  (defun map (x mapper)
    (cond ((not (exists? x))
           (error! "(map)" *e-guard* (show x)))
          ((not (function? mapper))
           (error! "(map)" *e-arg-1* "function, got " (show mapper)))
          ((or (string? x)
               (number? x))
           (mapper x))
          ((function? x) (lambda (...args) (mapper (.apply x null args))))
          ((future? x) (.then x mapper identity))
          ((function? (get x 'map)) (.map x mapper))
          ((hash? x)
           (.reduce (hash-pairs x)
                    (lambda (o [k v]) (hash-merge! o (hash k v)))
                    (hash)))
          ((dict? x)
           (let ((y (dict)))
            (each ([k v]) (dict-pairs x)
              (.add y k v))
            y))
          ((is-a x Set)  ; although there is no official support, we have to accept Sets
           (let ((y (new Set)))
             (each v x
               (.add y x))
             y))
          :else (error! "(map) needs the value to be a Functor"))))

(provide
  ;; flat-map :: Chain C. (C a, (a -> C b)) -> C b
  (defun flat-map (x chain-mapper)
    (cond ((not (exists? x))
           (error! "(flat-map|chain)" *e-guard* (show x)))
          ((not (function? chain-mapper))
           (error! "(flat-map|chain)" *e-arg-2* "function, got " (show chain-mapper)))
          ((function? x)
           (lambda (...args)
            (call (chain-mapper (.apply x null args)) ...args)))
          ((future? x)
           (.then x chain-mapper identity))
          ((function? (get x 'flat-map))
           (.flat-map x chain-mapper))
          ((list? x)
           (.reduce x 
                    (lambda (ls v)
                      (.concat ls v))
                    (list)))
          :else (error! "(flat-map|chain) needs the value to be a Chain"))))

(provide
  (defconstant chain flat-map))

(provide
  ;; bimap :: BiFunctor B. (B a, (_ -> b), (a -> b)) -> B b
  ;; --- future, list, bifunctors
  (defun bimap (x lhs-mapper rhs-mapper)
    (cond ((not (exists? x))
           (error! "(bimap)" *e-guard* (show x)))
          ((not (function? lhs-mapper))
           (error! "(bimap)" *e-arg-2* "function, got " (show lhs-mapper)))
          ((not (function? rhs-mapper))
           (error! "(bimap)" *e-arg-3* "function, got " (show rhs-mapper)))
          ((future? x)
           (.then x rhs-mapper lhs-mapper))
          ((list? x)
           (ternary (< (length x) 1)
                    (list (lhs-mapper)) 
                    (.map x rhs-mapper)))
          ((function? (get x 'bimap))
           (.bimap x lhs-mapper rhs-mapper))
          :else (error! "(bimap) needs the first argument to be a BiFunctor"))))

(provide
  ;; promap :: ProFunctor P. (P a b, (c -> a), (b -> d)) -> P c d
  ;; --- function, profunctors
  (defun promap (x pre-mapper post-mapper)
    (cond ((not (exists? x))
           (error! "(promap)" *e-guard* (show x)))
          ((function? pre-mapper)
           (error! "(promap)" *e-arg-2* "function, got " (show pre-mapper)))
          ((function? post-mapper)
           (error! "(promap)" *e-arg-3* "function, got " (show post-mapper)))
          ((function? x)
           (lambda (...args)
            (post-mapper (x (.apply pre-mapper null args)))))
          ((function? (get x 'promap))
           (.promap x pre-mapper post-mapper))
          :else (error! "(promap) needs the first argument to be a ProFunctor"))))



;;; ALGEBRAIC TYPES

;; --- coyo (-neda)
(provide
  (deftype coyo (value mapper)))

(set coyo 'of (lambda (value)
                (coyo value identity)))

(set coyo 'lift (lambda (value)
                  (cond ((not (exists? value))
                         (error! "(coyo.lift)" *e-guard* value))
                        :else (coyo.of value))))

(defmethod coyo to-string ()
  (let ((value (get this 'value))
        (fn (get this 'mapper)))
    (+ "(coyo " (show value) " " (show fn) ")")))

(defmethod coyo map (mapper)
  (cond ((not (function? mapper))
         (error! "(coyo.map)" *e-arg-1* "function, got " (show mapper)))
        :else (let ((value (get this 'value))
                    (run-self (get this 'mapper)))
                (coyo value (lambda (arg) (mapper (run-self arg)))))))

(defmethod coyo lower ()
  (let ((mapper (get this 'mapper))
        (value (get this 'value)))
    (cond ((not (function? mapper))
           (error! "(coyo.lower) requires the coyo:mapper property
                   to hold a function, but it holds " (show mapper)))
          ((not (exists? value))
           (error! "(coyo.lower) requires the coyo:value property
                   to hold a non (void) or (nil) value, but it holds "
                   (show value)))
          ((not (function? (get value 'map)))
           (error! "(coyo.lower) requires the coyo:value property
                   to implement the functor typeclass but it doesn't"))
          :else (coyo (.map value mapper) identity))))

(defmethod coyo reduce (reducer seed)
  (let ((value (get this 'value))
        (mapper (get this 'mapper)))
    (cond ((not (function? reducer))
           (error! "(coyo.reduce)" *e-arg-1* "function, got " (show reducer)))
          ((not (defined? seed))
           (error! "(coyo.reduce)" *e-arg-2* "non (void) value, got " (show seed)))
          ((function? (get value 'map) (get value 'reduce))
           (.reduce value
                    (lambda (acc val)
                      (reducer acc (mapper val)))
                    seed))
          :else (reducer seed (mapper value)))))


;; --- io
(provide
  (deftype io (unsafe-perform)))

(set io 'of (lambda (value)
              (io (lambda () value))))

(set io 'lift (lambda (value)
                (cond ((not (exists? value))
                       (error! "(io.lift)" *e-guard* value))
                      :else (io.of value))))

(set io 'empty (lambda ()
                (io (lambda (value) value))))

(set io 'identity (get io 'empty))

(defmethod io to-string ()
  (let ((fn (get this 'unsafe-perform)))
    (+ "(io " (show fn) ")")))

(defmethod io equals (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.equals)" *e-arg-1* "io, got " (show t-io)))
        :else (eql? (get this 'unsafe-perform)
                    (get t-io 'unsafe-perform))))

(defmethod io concat (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.concat)" *e-arg-1* "io, got " (show t-io)))
        :else (let ((run-self (get this 'unsafe-perform))
                    (run-that (get t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (run-that
                        (run-self arg)))))))

(defmethod io map (mapper)
  (cond ((not (function? mapper))
         (error! "(io.map)" *e-arg-1* "function, got " (show mapper)))
        :else (let ((run-self (get this 'unsafe-perform)))
                (io (lambda (arg)
                      (mapper (run-self arg)))))))

(defmethod io contramap (pre-mapper)
  (cond ((not (function? pre-mapper))
         (error! "(io.contramp)" *e-arg-1* "function, got " (show pre-mapper)))
        :else (let ((run-self (get this 'unsafe-perform)))
                (io (lambda (arg)
                      (run-self (pre-mapper arg)))))))

(defmethod io promap (pre-mapper post-mapper)
  (cond ((not (function? pre-mapper))
         (error! "(io.promap)" *e-arg-1* "function, got " (show pre-mapper)))
        ((not (function? post-mapper))
         (error! "(io.promap)" *e-arg-2* "function, got " (show post-mapper)))
        :else (let ((run-self (get this 'unsafe-perform)))
                (io (lambda (arg)
                      (post-mapper (run-self (pre-mapper arg))))))))

(defmethod io ap (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.ap)" *e-arg-1* "io, got " (show t-io)))
        :else (let ((run-self (get this 'unsafe-perform))
                    (run-that (get t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (call (run-self run-that) arg))))))

(defmethod io flat-map (to-io-mapper)
  (cond ((not (function? to-io-mapper))
         (error! "(io.flat-map | io.chain)" *e-arg-1* "io returning function, got " (show to-io-mapper)))
        :else (let ((run-self (get this 'unsafe-perform)))
                (io (lambda (arg)
                      (.unsafe-perform (to-io-mapper (run-self arg)) arg))))))

(set (get io 'prototype) 'chain (get io 'prototype 'flat-map))

(defmethod io compose (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.compose)" *e-arg-1* "io, got " (show t-io)))
        :else (let ((run-self (get this 'unsafe-perform))
                    (run-that (get t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (run-that
                        (run-self arg)))))))

(defmethod io run-io (arg)
  (.unsafe-perform this arg))



;; --- maybe
(provide
  (defsum maybe ((nothing) (just value))))

(set maybe 'of (lambda (value)
                (maybe.just value)))

(set maybe 'lift (lambda (value)
                  (cond ((not (exists? value))
                         (maybe.nothing))
                        :else (maybe.of value))))

(set maybe 'empty (lambda ()
                    (maybe.nothing)))

(set maybe 'zero (lambda ()
                  (maybe.nothing)))

(defmethod maybe to-string ()
  (.match this (hash nothing (lambda () 
                               "(maybe.nothing)")
                     just (lambda (value)
                            (+ "(maybe.just " (show value) ")")))))

(defmethod maybe equals (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.equals)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda ()
                          (.match t-maybe
                                  (hash nothing (lambda () true)
                                        just (lambda () false))))
                just (lambda (value)
                      (.match t-maybe 
                              (hash nothing (lambda ()
                                              false)
                                    just (lambda (t-value)
                                           (if (function? (get value 'equals))  
                                               (.equals value t-value)
                                               (eql? value t-value)))))))))

(defmethod maybe concat (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.concat)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda ()
                          (maybe.nothing))
                just (lambda (value)
                       (.match t-maybe
                               (hash nothing (lambda () t-maybe)
                                     just (lambda (t-value)
                                            (let ((cnt (get value 'concat)))
                                              (when (not (function? cnt))
                                                (error! "(maybe.concat) cannot
                                                        concat when both of
                                                        the carried values
                                                        implement the
                                                        semigroup
                                                        typeclass"))
                                              (.call cnt value t-value)))))))))

(defmethod maybe map (mapper)
  (cond ((not (function? mapper))
         (error! "(maybe.map)" *e-arg-1* "function, got " (show mapper)))
        :else (.match this 
                      (hash nothing (lambda ()
                                      (maybe.nothing))
                            just (lambda (value) 
                                  (maybe.lift (mapper value))))))) 

(defmethod maybe ap (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.ap)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda () 
                          (maybe.nothing))
                just (lambda (value)
                      (.map t-maybe value)))))

(defmethod maybe flat-map (to-maybe-mapper)
  (cond ((not (function? to-maybe-mapper))
         (error! "(maybe.flat-map|maybe.chain)" *e-arg-1* "function, got " (show to-maybe-mapper)))
        :else (.match this
                      (hash nothing (lambda ()
                                      (maybe.nothing))
                            just (lambda (value)
                                  (to-maybe-mapper value))))))

(set (get maybe 'prototype) 'chain (get maybe 'prototype 'flat-map))

(defmethod maybe bimap (transform-nothing transform-just)
  (cond ((not (function? transform-nothing))
         (error! "(maybe.bimap)" *e-arg-1* "function, got " (show transform-nothing)))
        ((not (function? transform-just))
         (error! "(maybe.bimap)" *e-arg-2* "function, got " (show transform-just)))
        :else (.match this
                      (hash nothing (lambda () (transform-nothing))
                            just (lambda (value) (transform-just value))))))

(defmethod maybe alt (t-maybe)
  (cond ((not (.is maybe t-maybe))
         (error! "(maybe.alt)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
        :else (.match this
                      (hash nothing (lambda () t-maybe)
                            just (lambda (value) (maybe.just value))))))

(defmethod maybe reduce (reducer seed)
  (cond ((not (function? reducer))
         (error! "(maybe.reduce)" *e-arg-1* "function, got " (show reducer)))
        ((not (defined? seed))
         (error! "(maybe.reduce)" *e-arg-2* "non (void) value, got " (show seed)))
        :else (.match this
                      (hash nothing (lambda () seed)
                            just (lambda (value) (reducer seed value))))))

(defmethod maybe traverse (lift transformer)
  (cond ((not (function? lift))
         (error! "(maybe.traverse)" *e-arg-1* "function, got " (show lift)))
        (not (function? transformer)
         (error! "(maybe.traverse)" *e-arg-2* "function, got " (show transformer)))
        :else (.match this
                      (hash nothing (lambda () 
                                      (lift (maybe.nothing)))
                            just (lambda (value)
                                  (.map (transformer value) maybe.of))))))

(defmethod maybe sequence (lift)
  (cond ((not (function? lift))
         (error! "(maybe.sequence)" *e-arg-1* "function, got " (show lift)))
        :else (.traverse this lift identity)))



;; --- either
(provide
  (defsum either ((left error)
                  (right value))))

(set either 'of (lambda (value))
                (either.right value))

(set either 'lift (lambda (value))
                  (cond ((not (exists? value))
                         (either.left (error "")))
                        :else (either.of value)))

(set either 'empty (lambda ()
                    (either.right (list))))

(set either 'zero (lambda ())
                  (either.left (error "either-zero")))

(defmethod either to-string ()
  (.match this (hash left (lambda (error) 
                               "(either.left " (show error) ")")
                     right (lambda (value)
                            (+ "(either.right " (show value) ")")))))

(defmethod either equals (t-either)
  (when (not (.is either t-either))
    (error! "(either.equals)" *e-arg-1* "instance of either, got " (show t-either)))
  (.match this
          (hash left (lambda ()
                      (.match t-either
                              (hash left (lambda () true)
                                    right (lambda () false))))
                right (lambda (value)
                        (.match t-either 
                                (hash left (lambda ()
                                            false)
                                      right (lambda (t-value)
                                             (if (function? (get value 'equals))  
                                                 (.equals value t-value)
                                                 (eql? value t-value)))))))))

(defmethod either concat (t-either)
  (when (not (.is either t-either))
    (error! "(either.concat)" *e-arg-1* "instance of either, got " (show t-either)))
  (.match this
          (hash left (lambda (error) (either.left error))
                right (lambda (value)
                       (.match t-either
                               (hash left (lambda () t-either)
                                     right (lambda (t-value)
                                            (let ((cnt (get value 'concat)))
                                              (when (not (function? cnt))
                                                (error! "(either.concat) cannot
                                                        concat when both of
                                                        the carried values
                                                        implement the
                                                        semigroup
                                                        typeclass"))
                                              (.call cnt value t-value)))))))))

(defmethod either map (mapper)
  (cond ((not (function? mapper))
         (error! "(either.map)" *e-arg-1* "function, got " (show mapper)))
        :else (.match this 
                      (hash left (lambda (error)
                                  (either.left error))
                            right (lambda (value) 
                                   (either.lift (mapper value))))))) 

(defmethod either ap (t-either)
  (when (not (.is either t-either))
    (error! "(either.ap)" *e-arg-1* "instance of either, got " (show t-either)))
  (.match this
          (hash left (lambda (error) 
                      (either.left error))
                right (lambda (value)
                       (.map t-either value)))))

(defmethod either flat-map (to-either-mapper)
  (cond ((not (function? to-either-mapper))
         (error! "(either.flat-map|either.chain)" *e-arg-1* "function, got " (show to-either-mapper)))
        :else (.match this
                      (hash left (lambda (error)
                                  (either.left error))
                            right (lambda (value)
                                   (to-either-mapper value))))))

(set (get either 'prototype) 'chain (get either 'prototype 'flat-map))

(defmethod either bimap (transform-left transform-right)
  (cond ((not (function? transform-left))
         (error! "(either.bimap)" *e-arg-1* "function, got " (show transform-left)))
        ((not (function? transform-right))
         (error! "(either.bimap)" *e-arg-2* "function, got " (show transform-right)))
        :else (.match this
                      (hash left (lambda (error) (transform-left error))
                            right (lambda (value) (transform-right value))))))

(defmethod either alt (t-either)
  (cond ((not (.is either t-either))
         (error! "(either.alt)" *e-arg-1* "instance of either, got " (show t-either)))
        :else (.match this
                      (hash left (lambda () t-either)
                            right (lambda (value) (either.right value))))))

(defmethod either reduce (reducer seed)
  (cond ((not (function? reducer))
         (error! "(either.reduce)" *e-arg-1* "function, got " (show reducer)))
        ((not (defined? seed))
         (error! "(either.reduce)" *e-arg-2* "non (void) value, got " (show seed)))
        :else (.match this
                      (hash left (lambda () seed)
                            right (lambda (value) (reducer seed value))))))

(defmethod either traverse (lift transformer)
  (cond ((not (function? lift))
         (error! "(either.traverse)" *e-arg-1* "function, got " (show lift)))
        (not (function? transformer)
         (error! "(either.traverse)" *e-arg-2* "function, got " (show transformer)))
        :else (.match this
                      (hash left (lambda (error) 
                                  (lift (either.left error)))
                            right (lambda (value)
                                   (.map (transformer value) either.of))))))

(defmethod either sequence (lift)
  (cond ((not (function? lift))
         (error! "(either.sequence)" *e-arg-1* "function, got " (show lift)))
        :else (.traverse this lift identity)))


;; --- proof
(provide
  (defsum proof ((falsy errors)
                 (truthy value))))

(set proof 'of (lambda (value)
                (proof.truthy value)))

(set proof 'lift (lambda (value)
                  (cond ((nothing? value)
                         (proof.falsy (list (error *e-no-value*))))
                        ((error? value)
                         (proof.falsy (list value)))
                        :else (proof.truthy value))))

(set proof 'empty (lambda ()
                    (proof.truthy true)))

(set proof 'zero (lambda ()
                  (proof.falsy (list (error "ProofZero")))))

(defmethod proof equals (t-proof)
  (cond ((not (.is proof t-proof))
         (error! "(proof.equals)" *e-arg-1* "instance of proof, got " (show t-proof)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (.match t-proof
                                            (hash truthy (lambda (t-value)
                                                          (equals value
                                                                  t-value))
                                                  falsy (lambda ()
                                                          false))))
                            falsy (lambda (errors)
                                    (.match t-proof
                                            (hash truthy (lambda () false)
                                                  falsy (lambda (t-errors)
                                                          (.every errors
                                                                  (lambda (e i)
                                                                    (equals e
                                                                            (get t-errors i))))))))))))

(defmethod proof concat (t-proof)
  (cond ((not (.is proof t-proof))
         (error! "(proof.concat)" *e-arg-1* "proof, got " (show t-proof)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (.match t-proof
                                            (hash truthy (lambda (t-value)
                                                          (proof.truthy t-value))
                                                  falsy (lambda (errors)
                                                          (proof.falsy errors)))))
                            falsy (lambda (errors)
                                    (.match t-proof
                                            (hash truthy (lambda ()
                                                          (proof.falsy errors))
                                                  falsy (lambda (t-errors)
                                                          (proof.falsy 
                                                            (.concat errors
                                                                     t-errors))))))))))

(defmethod proof map (mapper)
  (cond ((not (function? mapper))
         (error! "(proof.map)" *e-arg-1* "function, got " (show mapper)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (proof.lift (mapper value)))
                            falsy (lambda (errors)
                                    (proof.falsy errors))))))
                    
(defmethod proof bimap (lhs-mapper rhs-mapper)
  (cond ((not (function? lhs-mapper))
         (error! "(proof.bimap)" *e-arg-1* "function, got " (show lhs-mapper)))
        ((not (function? rhs-mapper))
         (error! "(proof.bimap)" *e-arg-2* "function, got " (show rhs-mapper)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (proof.lift (rhs-mapper value)))
                            falsy (lambda (errors)
                                    (proof.falsy (.map errors lhs-mapper)))))))

(defmethod proof ap (t-proof)
  (cond ((not (.is proof t-proof))
         (error! "(proof.ap)" *e-arg-1* "proof, got " (show t-proof)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (.match t-proof
                                            (hash truthy (lambda (t-value)
                                                          (proof.lift (value t-value)))
                                                  falsy (lambda (t-errors)
                                                          (proof.falsy t-errors)))))
                            falsy (lambda (errors)
                                    (.match t-proof
                                            (hash truthy (lambda ()
                                                          (proof.falsy errors))
                                                  falsy (lambda (t-errors)
                                                          (proof.falsy 
                                                            (.concat errors 
                                                                     t-errors))))))))))

(defmethod proof alt (t-proof)
  (cond ((not (.is proof t-proof))
         (error! "(proof.alt)" *e-arg-1* "proof, got " (show t-proof)))
        :else (.match this
                      (hash truthy (lambda (value) (proof.truthy value))
                            falsy (lambda () t-proof)))))
