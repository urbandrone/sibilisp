(comment prelude)

;;;;                  PRELUDE - README
;;;; --------------------------------------------
;;;; This file contains definitions for all the functions that 
;;;; are parts of sibilisp's prelude. It uses a modified syntax
;;;; of Hindley-Milner type notation to describe it's included
;;;; function's arguments and outputs.
;;;; Here's a short description:
;;;; - Specified types are written with their respective constructor
;;;;    Example: String, Boolean
;;;; - Abstract types are written as lowercase symbols
;;;;   Example: a, b
;;;; - In case a type is ireelevant, the underscore is used in place
;;;;   Example: _
;;;; - Null is written as unit/nil/empty list
;;;;   Example: ()
;;;; - If a function requires multiple arguments at once, braces
;;;;   and commas are used
;;;;   Example: (String, String)
;;;; - Functions are written with arrow notation
;;;;   Example: (String, String) -> String
;;;; - Type classes are written in capital case symbols
;;;;   Example: Functor, Semigroup
;;;; - Type restrictions for type classes may be added to functions
;;;;   Example: Functor F. (F a, (a -> b)) -> F b
;;;; - Lists may be written with square braces instead of the
;;;;   fully specified types
;;;;   Example (full specified): (List String Number)
;;;;   Example (appreviated): [String Number]
;;;; - Hashes may be written with curly braces instead of the
;;;;   fully specified types
;;;;   Example (full specified): (Hash :a Number)
;;;;   Example (appreviated): { :a Number }


;;; CONSTANTS
(defconstant *e-no-value* "E_NO_VALUE")
(defconstant *e-guard* " guards agains (nil) and (void) values, got ")
(defconstant *e-arg-1* " expects argument 1 to be a ")
(defconstant *e-arg-2* " expects argument 2 to be a ")
(defconstant *e-arg-3* " expects argument 3 to be a ")

;;; BASIC LAMBDA OPERATORS (I, K, S)
(provide
  ;; identity :: a -> a
  (defun identity (a) a))

(provide
  ;; constantly :: a -> () -> a
  (defun constantly (a)
    (lambda () a)))



;;; LANGUAGE TYPE CHECK UTILITIES
(provide
  ;; list-of? :: ([_], (_ -> Boolean)) -> Boolean
  ;; --- (list-of? *items* (lambda (x) (string? x)))
  (defun list-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(list-of?)" *e-arg-2* "function, got " predicate))
          :else (and (list? x)
                     (.every x predicate)))))

(provide
  ;; hash-of? :: ({ :a _ }, (_ -> Boolean)) -> Boolean
  ;; --- (hash-of? *items* (lambda (x) (string? x)))
  (defun hash-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(hash-of?)" *e-arg-2* "function, got " predicate))
          :else (and (hash? x)
                     (.every (hash-pairs x) (lambda ([_ v]) (predicate v)))))))

(provide 
  ;; dict-of? :: ((Dict :a _), (_ -> Boolean)) -> Boolean
  ;; --- (dict-of? *items* (lambda (x) (string? x)))
  (defun dict-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(dict-of?)" *e-arg-2* "function, got " predicate))
          :else (and (dict? x)
                     (.every (.entries x) (lambda ([_ v]) (predicate v)))))))

(provide 
  ;; mset-of? :: ((mset _), (_ -> Boolean)) -> Boolean
  ;; --- (mset-of? *items* (lambda (x) (string? x)))
  (defun mset-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(mset-of?)" *e-arg-2* "function, got " predicate))
          :else (and (mset? x)
                     (.every (.entries x) (lambda ([_ v]) (predicate v)))))))



;;; FUNCTION FUNCTIONS
(provide
  ;; converge :: (((a, b, ...) -> c), [(_ -> a), (_ -> b), ...]) -> ((_, _, ...) -> c)
  ;; --- (converge (lambda (prefix word)
  ;;                    (+ prefix "-" word))
  ;;                  (list (thunk "Hello")
  ;;                        (lambda (w) (.to-lower-case w))))
  (defun converge (combine branches)
    (cond ((not (function? combine))
           (error! "(converge)" *e-arg-1* "function, got " combine))
          ((not (list-of? branches (lambda (v) (function? v))))
           (error! "(converge)" *e-arg-2* "list of functions, got " branches))
          :else (lambda (...args)
                  (.apply combine
                          (nil)
                          (.map branches
                              (lambda (branch i)
                                (.apply branch (nil) args))))))))

(provide
  ;; memoize :: ((a, b, ...) -> c) -> ((a, b, ...) -> c)
  ;; --- (memoize (lambda ()))
  (defun memoize (compute)
    (cond ((not (function? compute))
           (error! "(memoize)" *e-arg-1* "function, got " compute))
          :else (let ((cache (dict)))
                  (lambda (...args)
                    (cond ((.has cache args)
                           (.get cache args))
                          :else (pipe cache
                                      (.set args (.apply compute (nil) args))
                                      (.get args)))))))) 
  


;;; GENERAL PURPOSE OPERATIONS
(provide
  ;; show :: a -> String
  (defun show (x)
    (cond ((eq? (nil) x)
           "(nil)")
          ((nan? x)
           "(nan)")
          ((error? x)
           (+ "(error " x.name ": " x.message ")"))
          ((string? x)
           (+ "(string \"" x "\")"))
          ((number? x)
           (+ "(number " x ")"))
          ((function? x)
           (+ "(function " (or (getf x 'name) "lambda") ")"))
          ((generator? x)
           (+ "(generator " (getf x 'name) ")"))
          ((list? x)
           (+ "(list" 
              (.reduce x 
                       (lambda (a v)
                        (+ a " " (show v))) 
                       "")
              ")"))
          ((mset? x)
           (+ "(mset" 
              (.reduce (as-list x) 
                       (lambda (a v)
                        (+ a " " (show v)))
                       "")
              ")"))
          ((hash? x)
           (+ "(hash" (.reduce (hash-pairs x)
                               (lambda (a [k v])
                                (+ a " :" k " " (show v))) "") ")"))
          ((dict? x)
           (+ "(dict" (.reduce (.entries x)
                               (lambda (a [k v])
                                 (+ a " :" (show k) " " (show v)))
                               "") ")"))
          ((future? x)
           "(future)")
          ((date? x)
           (+ "(date" (.get-full-year x)
              "-" (+ 1 (.get-month x))
              "-" (.get-date x) ")"))
          ((regex? x)
           (+ "(regex " (getf x 'source) " :flags " (getf x 'flags) ")"))
          ((method? x to-string)
           (.to-string x))
          :else (+ "(" (getf x 'constructor 'name) ")"))))


(provide
  ;; equals :: (a, b) -> Boolean
  (defun equals (x y)
      (cond ((nil? x) (nil? y))
            ((void? x) (void? y))
            ((string? x y) (eql? x y))
            ((function? x y) (eql? x y))
            ((number? x y) (eql? x y))
            ((regex? x y) (and 
                            (eql? (getf x 'source)
                                  (getf y 'source))
                            (eql? (getf x 'flag)
                                  (getf y 'flag))))
            ((date? x y) (eql? (as-number x) (as-number y)))
            ((generator? x y) (eql? x y))
            ((future? x y) (eql? x y))
            ((list? x y) (and (eql? (length x)
                                    (length y))
                              (.every 
                                x
                                (lambda (va i)
                                  (equals va (getf y i))))))
            ((mset? x y) (and (eql? (.size x)
                                    (.size y))
                              (equals (as-list x)
                                      (as-list y))))
            ((hash? x y) (let ((pa (hash-pairs x))
                               (pb (hash-pairs y)))
                          (and (eql? (length pa) (length pb)) 
                               (.every 
                                pa
                                (lambda ([k v])
                                  (equals v (getf y k)))))))
            ((dict? x y) (let ((pa (dict-pairs x))
                               (pb (dict-pairs y)))
                          (and (eql? (length pa) (length pb))
                               (.every
                                pa
                                (lambda ([k v])
                                  (equals v (.get y k)))))))
            ((method? x equals) (.equals x y))
            :else false)))

(provide
  ;; concat :: Semigroup S. (S a, S a) -> S a
  ;; --- string, function, list, mset, hash, dict, future, semigroupoid
  (defun concatenate (x y)
    (cond ((or (not (exists? x)) (not (exists? y)))
           (error! "(concatenate) cannot concatenate with a (void) or (nil) value"))
          ((string? x y) (+ x y))
          ((function? x y) (lambda (...args) (y (.apply x null args))))
          ((list? x y) (.concat x y))
          ((hash? x y) (hash-merge x y))
          ((mset? x y) (mset-merge x y))
          ((dict? x y) (dict-merge x y))
          ((future? x y) (future-all x y))
          ((method? x concat) (.concat x y))
          :else (error! "(concatenate) needs both arguments to be in the same semigroup"))))

(provide
  ;; map :: Functor F. (F a, (a -> b)) -> F b
  (defun map (x mapper)
    (cond ((not (exists? x))
           (error! "(map)" *e-guard* (show x)))
          ((not (function? mapper))
           (error! "(map)" *e-arg-1* "function, got " (show mapper)))
          ((function? x) (lambda (...args) (mapper (.apply x null args))))
          ((future? x) (.then x mapper identity))
          ((method? x map) (.map x mapper))
          ((hash? x)
           (.reduce (hash-pairs x)
                    (lambda (o [k v]) (hash-merge! o (hash k (mapper v))))
                    (hash)))
          ((dict? x)
           (let ((y (dict)))
            (each ([k v]) (dict-pairs x)
              (.set y k (mapper v)))
            y))
          ((mset? x)
           (let ((y (mset)))
            (each v x
              (.add y (mapper v)))
            y))
          :else (error! "(map) needs the value to be a Functor"))))

(provide
  ;; ap :: Functor F, Apply A. (F a, A (a -> b)) -> F b
  (defun ap (x applicable)
    (cond ((not (exists? x))
           (error! "(ap)" *e-guard* (show x)))
          ((not (or (exists? applicable)
                    (function? applicable)
                    (method? applicable ap)
                    (list? applicable)
                    (mset? applicable)))
           (error! "(ap)" *e-arg-2* "Apply, got " (show applicable)))
          ((function? x applicable)
           (lambda (...args)
            (call (applicable ...args) (x ...args) ...args)))
          ((future? x applicable)
           (.then applicable (lambda (f) (.then x f identity))))
          ((and (method? x map) (method? applicable ap))
           (.ap applicable x))
          ((list? x applicable)
           (.map x (lambda (v)
                    (.reduce applicable 
                             (lambda (y f)
                              (f y))
                             v))))
          ((mset? x applicable)
           (let ((y (mset)))
            (each v x
              (each f applicable
                (.add y (f v))))
            y))
          ((hash? x applicable)
           (let ((f (hash-pairs applicable)))
            (.reduce (hash-pairs x)
                     (lambda (a [k v])
                      (.reduce f
                               (lambda (r [l f])
                                (if (eql? k l)
                                  (do (setf r k (f v))
                                      r)
                                  (do (setf r k v)
                                      r)))
                               a))
                     (hash-create))))
            
          ((dict? x applicable)
           (let ((f (dict-pairs applicable)))
            (.reduce (dict-pairs x)
                     (lambda (a [k v])
                      (.reduce f
                               (lambda (r [l f])
                                (if (eql? k l)
                                    (.set r k (f v))
                                    (.set r k v)))
                               a))
                     (dict))))
          :else (error! "(ap) needs the value to be a Functor"))))

(provide
  ;; flat-map :: Chain C. (C a, (a -> C b)) -> C b
  (defun flat-map (x chain-mapper)
    (cond ((not (exists? x))
           (error! "(flat-map|chain)" *e-guard* (show x)))
          ((not (function? chain-mapper))
           (error! "(flat-map|chain)" *e-arg-2* "function, got " (show chain-mapper)))
          ((function? x)
           (lambda (...args)
            (call (chain-mapper (.apply x null args)) ...args)))
          ((future? x)
           (.then x chain-mapper identity))
          ((method? x flat-map)
           (.flat-map x chain-mapper))
          ((method? x chain)
           (.chain x chain-mapper))
          ((list? x)
           (.reduce x 
                    (lambda (ls v)
                      (.concat ls v))
                    (list)))
          ((mset? x)
           (let ((y (mset)))
            (each v x
              (assign y (mset-merge! y (chain-mapper v))))
            y))
          :else (error! "(flat-map|chain) needs the value to be a Chain"))))

(provide
  (defconstant chain flat-map))

(provide
  ;; bimap :: BiFunctor B. (B a, (_ -> b), (a -> b)) -> B b
  ;; --- future, list, bifunctors
  (defun bimap (x lhs-mapper rhs-mapper)
    (cond ((not (exists? x))
           (error! "(bimap)" *e-guard* (show x)))
          ((not (function? lhs-mapper))
           (error! "(bimap)" *e-arg-2* "function, got " (show lhs-mapper)))
          ((not (function? rhs-mapper))
           (error! "(bimap)" *e-arg-3* "function, got " (show rhs-mapper)))
          ((future? x)
           (.then x rhs-mapper (#> (future-resolve (lhs-mapper)))))
          ((list? x)
           (ternary (< (length x) 1)
                    (list (lhs-mapper)) 
                    (.map x rhs-mapper)))
          ((mset? x)
           (ternary (< (getf x 'size) 1)
                    (mset (lhs-mapper))
                    (mset ...(.map (as-list x) rhs-mapper))))
          ((method? x bimap)
           (.bimap x lhs-mapper rhs-mapper))
          :else (error! "(bimap) needs the first argument to be a BiFunctor"))))

(provide
  ;; contramap :: Contrafunctor C. (C a b, (a -> c)) -> C c b
  (defun contramap (x lhs-mapper)
    (bimap x lhs-mapper identity)))

(provide
  ;; promap :: ProFunctor P. (P a b, (c -> a), (b -> d)) -> P c d
  ;; --- function, profunctors
  (defun promap (x pre-mapper post-mapper)
    (cond ((not (exists? x))
           (error! "(promap)" *e-guard* (show x)))
          ((not (function? pre-mapper))
           (error! "(promap)" *e-arg-2* "function, got " (show pre-mapper)))
          ((not (function? post-mapper))
           (error! "(promap)" *e-arg-3* "function, got " (show post-mapper)))
          ((function? x)
           (lambda (...args)
            (post-mapper (x (.apply pre-mapper null args)))))
          ((method? x promap)
           (.promap x pre-mapper post-mapper))
          :else (error! "(promap) needs the first argument to be a ProFunctor"))))

(provide
  ;; reduce :: Foldable F. (F a, ((b a) -> b) -> *opt b -> b)
  ;; --- list, set
  (defun reduce (x reducer seed)
    (cond ((not (exists? x))
           (error! "(reduce)" *e-guard* (show x)))
          ((not (function? reducer))
           (error! "(reduce)" *e-arg-2* "function, got " (show reducer)))
          ((mset? x)
           (let ((y (mset-values x)))
            (.reduce y reducer seed)))
          ((method? x reduce)
           (.reduce x reducer seed))
          :else (error! "(reduce) needs the first argument to be a Foldable"))))


(provide
  ;; fold-map :: Foldable F, Semigroup S. (F a, (a -> S b)) -> S b
  (defun fold-map (x lift-map)
    (cond ((not (exists? x))
           (error! "(reduce)" *e-guard* (show x)))
          ((not (function? lift-map))
           (error! "(fold-map)" *e-arg-2* "function, got " (show lift-map)))
          ((mset? x)
           (let ((y (mset-values x)))
            (.reduce y
                     (lambda (a value)
                      (ternary (nil? a)
                               (lift-map value)
                               (.concat a (lift-map value))))
                     (nil))))
          ((method? x fold-map)
           (.fold-map x lift-map))
          ((method? x reduce)
           (.reduce x
                    (lambda (a value)
                      (ternary (nil? a)
                               (lift-map value)
                               (.concat a (lift-map value))))
                    (nil)))
          :else (error! "(fold-map) needs the first argument to be a Foldable"))))
          
(provide
  ;; fold :: Foldable F, Semigroup S. (F a, (a -> S a)) -> S a
  (defun fold (x lift)
    (cond ((not (function? lift))
           (error! "(fold)" *e-arg-2* "function, got " (show lift)))
          ((mset? x)
           (let ((y (mset-values x)))
            (.reduce y
                     (lambda (a value)
                      (ternary (nil? a)
                               (lift value)
                               (.concat a (lift value))))
                     (nil))))
          ((method? x fold)
           (.fold x lift))
          ((method? x reduce)
           (.reduce x
             (lambda (a value)
               (ternary (nil? a)
                        (lift value)
                        (.concat a (lift value))))
             (nil)))
          :else (error! "(fold) needs the first argument to be a Foldable"))))

(provide
  ;; traverse :: Traversable T, Applicative A. (T a, (a -> A a), (a -> A b)) -> A T b
  (defun traverse (x lift transformer)
    (cond ((not (exists? x))
           (error! "(traverse)" *e-arg-1* "Traversable, got " (show x)))
          ((not (function? lift))
           (error! "(traverse)" *e-arg-2* "function, got " (show lift)))
          ((not (function? transformer))
           (error! "(traverse)" *e-arg-3* "function, got " (show transformer)))
          ((mset? x)
           (let ((y (mset-values x)))
            (.reduce y
                     (lambda (a value)
                      (pipe 
                        (transformer value)
                        (.map (lambda (x)
                                (lambda (y)
                                  (mset-merge! y x))))
                        (.ap a)))
                     (lift (mset)))))
          ((list? x)
           (.reduce x
                    (lambda (a value)
                      (pipe
                        (transformer value)
                        (.map (lambda (x)
                                (lambda (y)
                                  (.concat y x))))
                        (.ap a)))
                    (lift (list))))
          ((method? x traverse)
           (.traverse x lift transformer))
          :else (error! "(traverse) needs the first argument to be a Traversable"))))

(provide
  ;; sequence :: Traversable T, Applicative A. (T A a, (a -> A a)) -> A T a
  (defun sequence (x lift)
    (cond ((not (exists? x))
           (error! "(sequence)" *e-arg-1* "Traversable, got " (show x)))
          ((not (function? lift))
           (error! "(sequence)" *e-arg-2* "function, got " (show lift)))
          ((mset? x)
           (let ((y (mset-values x)))
            (.reduce y
                     (lambda (a value)
                      (pipe
                        (.map value (lambda (x)
                                      (lambda (y)
                                        (mset-merge! y x))))
                        (.ap a)))
                     (lift (mset)))))
          ((list? x)
           (.reduce x
                    (lambda (a value)
                      (pipe
                        (.map value (lambda (x)
                                      (lambda (y)
                                        (.concat y x))))
                        (.ap a)))
                    (lift (list))))
          ((method? x sequence)
           (.sequence x lift transformer))
          :else (error! "(sequence) needs the first argument to be a Traversable"))))

(provide
  ;; alt :: Alt A. (A a, A a) -> A a
  (defun alt (x altern)
    (cond ((not (exists? x))
           (error! "(alt)" *e-arg-1* "Alternative, got " (show x)))
          ((not (exists? altern))
           (error! "(alt)" *e-arg-2* "Alternative, got " (show altern)))
          ((mset? x altern)
           (let ((l (getf x 'size)))
            (ternary (< l 1) altern x)))
          ((list? x altern)
           (let ((l (length x)))
            (ternary (< l 1) altern x)))
          ((method? x alt)
           (.alt x altern))
          :else (error! "(alt) expects both arguments to be Alternatives"))))

(provide
  ;; clone :: Clonable C. C a -> C a
  (defun clone (x)
    (cond ((or (string? x)
               (number? x)
               (function? x)
               (boolean? x)
               (nothing? x))
           x)
          ((list? x)
           (.map x (lambda (y) (clone y))))
          ((mset? x)
           (mset ...(.map (as-list x) (lambda (y) (clone y)))))
          ((hash? x)
           (.reduce (hash-pairs x)
                    (lambda (a [k v])
                      (setf a k (clone v))
                      a)
                    (hash-create)))
          ((dict? x)
           (.reduce (dict-pairs x)
                    (lambda (a [k v])
                      (.set a k (clone v)))
                    (dict)))
          ((date? x)
           (date-clone x))
          ((regex? x)
           (regex-clone x))
          ((method? x clone)
           (.clone x))
          :else (error! "(clone) doesn't know how to clone " (show x)))))


;;; LIST/MSET RELATED

(provide
  ;; zip :: List|MSet LM. (LM a, LM b) -> LM LM a b
  (defun zip (ls-a ls-b)
    (cond ((list? ls-a ls-b)
           (let ((l (min (length ls-a) (length ls-b)))
                 (i 0)
                 (r (list)))
            (while (< i l)
              (.push r (list (getf ls-a i) (getf ls-b i)))
              (incr-by i 1))
            r))
          ((mset? ls-a ls-b)
           (let* ((a (as-list ls-a))
                  (b (as-list ls-b))
                  (l (min (length a) (length b)))
                  (i 0)
                  (r (mset)))
            (while (< i l)
              (.add r (list (getf a i) (getf b i)))
              (incr-by i 1))
            r))
          :else (error! "(zip) expects both arguments to be a list or mset"))))
            
(provide
  (defun unzip (ls)
    (cond ((or (list? ls) (mset? ls))
           (let ((ks (list))
                 (vs (list)))
            (each ([k v]) ls
              (.push ks k)
              (.push vs v))
            (list ks vs)))
          :else (error! "(unzip) expects the argument to be a list or mset"))))

(provide
  (defun find (ls predicate)
    (cond ((not (function? predicate))
           (error! "(find)" *e-arg-2* "function, got " (show predicate)))
          ((and (list? ls) (function? (getf ls 'find)))
           (maybe.lift (.find ls predicate)))
          ((list? ls)
           (let ((l (length ls))
                 (i 0)
                 (m (nil)))
            (while (and (not m) (< i l))
              (when (predicate (getf ls i))
                (assign m (getf ls i)))
              (incr-by i 1))
            (maybe.lift m)))
          ((mset? ls)
           (let ((x (as-list ls))
                 (l (length x))
                 (i 0)
                 (m (nil)))
            (while (and (not m) (< i l))
              (when (predicate (getf x i))
                (assign m (getf x i)))
              (incr-by i 1))
            (maybe.lift m)))
          :else (error! "(find) expects the first argument to be a list or mset"))))

(provide
  (defun filter (ls predicate)
    (cond ((not (function? predicate))
           (error! "(filter)" *e-arg-2* "function, got " (show predicate)))
          ((list? ls)
           (.filter ls predicate))
          ((mset? ls)
           (let ((x (as-list ls)))
            (mset (.filter ls predicate))))
          :else (error! "(filter) expects the first argument to be a list or mset"))))

(provide
  (defconstant select filter))

(provide
  (defun reject (ls predicate)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(reject) expects the first argument to be a list or mset"))
          ((not (function? predicate))
           (error! "(reject)" *e-arg-2* "function, got " (show predicate)))
          :else (filter ls (lambda (x) (not (predicate x)))))))

(provide
  (defun unique (ls)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(unique)" *e-arg-1* "list or mset, got " (show ls)))
          ((list? ls)
           (as-list (mset ...ls)))
          :else ls)))

(provide
  (defun union (ls-a ls-b)
    (cond ((not (or (list? ls-a ls-b) (mset? ls-a ls-b)))
           (error! "(union) expects the arguments to both be lists or msets"))
          ((list? ls-a ls-b)
           (let ((ab (.concat ls-a ls-b)))
            (as-list (mset ...ab))))
          :else (mset ...(as-list ls-a)
                      ...(as-list ls-b)))))

(provide
  (defun intersection (ls-a ls-b)
    (cond ((not (or (list? ls-a ls-b) (mset? ls-a ls-b)))
           (error! "(intersection) expects the arguments to both be lists or msets"))
          ((list? ls-a ls-b)
           (let ((a (unique ls-a))
                 (b (unique ls-b))
                 (ab (list)))
            (each v a
              (when (> (.index-of b v) -1)
                (.push ab v)))
            (each v b
              (when (> (.index-of a v) -1)
                (.push ab v)))
            ab))
          :else (let ((ab (mset)))
                  (each v ls-a
                    (when (.has b v)
                      (.add ab v)))
                  (each v ls-b
                    (when (.has a v)
                      (.add ab v)))
                  ab))))

(provide
  (defun difference (ls-a ls-b)
    (cond ((not (or (list? ls-a ls-b) (mset? ls-a ls-b)))
           (error! "(difference) expects the arguments to both be lists or msets"))
          ((list? ls-a ls-b)
           (let ((a (unique ls-a))
                 (b (unique ls-b))
                 (ab (list)))
            (each v a
              (when (< (.index-of b v) 0)
                (.push ab v)))
            (each v b
              (when (< (.index-of a v) 0)
                (.push ab v)))
            ab))
          :else (let ((ab (mset)))
                  (each v ls-a
                    (when (not (.has b v))
                      (.add ab v)))
                  (each v ls-b
                    (when (not (.has a v))
                      (.add ab v)))
                  ab))))

(provide
  (defun take (ls count)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(take)" *e-arg-1* "list or mset, got " (show ls)))
          ((not (number? count))
           (error! "(take)" *e-arg-2* "number, got " (show count)))
          ((list? ls)
           (ternary (<= count (length ls))
                    (.slice ls 0 count)
                    ls))
          :else (ternary (<= count (getf ls 'size))
                         (let* ((xs (as-list ls))
                                (ys (.slice xs 0 count)))
                          (mset ...ys))
                         ls))))

(provide
  (defun drop (ls count)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(drop)" *e-arg-1* "list or mset, got " (show ls)))
          ((not (number? count))
           (error! "(drop)" *e-arg-2* "number, got " (show count)))
          ((list? ls)
           (ternary (<= count (length ls))
                    (.slice ls count)
                    (list)))
          :else (ternary (<= count (getf ls 'size))
                         (let* ((xs (as-list ls))
                                (ys (.slice xs count)))
                          (mset ...ys))
                         (mset)))))

(provide
  (defun partition (ls count)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(partition)" *e-arg-1* "list or mset, got " (show ls)))
          ((not (number? count))
           (error! "(partition)" *e-arg-2* "number, got " (show count)))
          ((list? ls)
           (let ((xs (list)
                  (i 0)
                  (l (length ls))))
            (while (< i l)
              (let ((a (.slice ls i count)))
                (.push xs a)
                (incr-by i count)))
            xs))
          :else (let ((xs (as-list ls))
                      (ys (list))
                      (i 0)
                      (l (length xs)))
                  (while (< i l)
                    (let ((a (.slice xs i count)))
                      (.push ys a)
                      (incr-by i count)))
                  (mset ...ys)))))

(provide
  (defun partition-with (ls partitioner)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(partition-with)" *e-arg-1* "list or mset, got " (show ls)))
          ((not (function? partitioner))
           (error! "(partition-with)" *e-arg-2* "list or mset, got " (show ls)))
          ((list? ls)
           (.reduce ls
                    (#(acc a)
                      (cond ((nil? acc) (list (list a)))
                            ((not (partitioner a))
                             (let ((b (last acc)))
                              (.push b a)
                              acc))
                            :else (.concat acc (list (list a)))))
                    (nil)))
          :else (let ((xs (as-list ls)))
                  (mset ...(.reduce xs
                                    (#(acc x)
                                      (cond ((nil? acc) (list (list x)))
                                            ((not (partitioner a))
                                             (let ((b (last acc)))
                                               (.push b a)
                                               acc))
                                            :else (.concat acc (list (list x)))))
                                    (nil)))))))

(provide
  (defun group-by (ls grouper)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(group-by)" *e-arg-1* "list or mset, got " (show ls)))
          ((not (function? grouper))
           (error! "(group-by)" *e-arg-2* "function, got " (show grouper)))
          ((list? ls)
           (.reduce xs (#(acc x)
                        (let ((k (as-string (grouper x))))
                          (when (not (has-key? acc k))
                            (setf acc k (list)))
                          (.push (getf acc k) x)
                          acc))
                       (hash-create)))
          :else (let ((xs (as-list ls)))
                  (.reduce xs (#(acc x)
                                (let ((k (as-string (grouper x))))
                                  (when (not (has-key? acc k))
                                    (setf acc k (list)))
                                  (.push (getf acc k) x)
                                  acc))
                              (hash-create))))))
                               

(provide
  (defun keep (ls)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(keep)" *e-arg-1* "list or mset, got " (show ls)))
          ((list? ls)
           (.reduce ls
                    (#(acc a)
                      (ternary (and (exists? a) 
                                    (not (nan? a))) 
                               (.concat acc a) 
                               acc))
                    (list)))
          :else (let ((xs (as-list ls)))
                  (mset ...(.reduce xs
                                    (#(acc x)
                                      (ternary (and (exists? x)
                                                    (not (nan? x)))
                                               (.concat acc x)
                                               acc))
                                    (list)))))))

(provide
  (defun intersperse (ls separator)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(intersperse)" *e-arg-1* "list or mset, got " (show ls)))
          ((nothing? separator)
           (error! "(intersperse)" *e-arg-2* "to exist, got " (show separator)))
          ((list? ls)
           (.reduce ls
                    (#(acc x)
                      (ternary (< (length acc) 1)
                               (.concat acc x)
                               (.concat acc (list separator x))))
                    (list)))
          :else (let ((xs (as-list ls)))
                  (.reduce xs
                           (#(acc x)
                            (ternary (< (length acc) 1)
                                     (.concat acc x)
                                     (.concat acc (list separator x))))
                           (list))))))



;;; LENSES
(defsum lens* ((lval value)
               (lconst value)))
(defmethod lens* map (f)
  (match-sum this ((:lval (v) (lens*.lval (f v)))
                   (:lconst (v) (lens*.lconst v)))))

(provide
  (defun create-lens (gets sets)
    (lambda (k)
      (lambda (a f)
        (map (f (gets k a)) (lambda (b) (sets k b a)))))))

(setf create-lens
      'hlens
      (create-lens
        (lambda (k a)
          (let ((b (getf a k)))
            (ternary (exists? b) b (nil))))
        (lambda (k v a)
          (let ((b (if (list? a)
                       (list-clone a)
                       (hash? a)
                       (hash-clone a))))
            (setf b k v)
            b))))

(setf create-lens
      'dlens
      (create-lens
        (lambda (k a)
          (ternary (.has a k) (.get a k) (nil)))
        (lambda (k v a)
          (let ((b (dict-clone a)))
            (.set b k v)))))

(provide
  (defun hash-lens (...keys)
    (.reduce keys
             (lambda (a k)
              (setf a k (create-lens.hlens k))
              a)
            (hash :nth (getf create-lens 'hlens)))))

(provide
  (defun dict-lens (...keys)
    (.reduce keys
             (lambda (a k)
              (setf a k (create-lens.dlens k))
              a)
             (hash :nth (getf create-lens 'dlens)))))

(provide
  (defun lset (a l v)
    (getf
      (l a (lambda ()
            (lens*.lval v)))
      'value)))

(provide
  (defun lget (a l)
    (getf (l a lens*.lconst) 'value)))

(provide
  (defun lmap (a l f)
    (getf
      (l a (lambda (x)
            (lens*.lval (f x))))
      'value)))
          

;;; ALGEBRAIC TYPES

;; --- coyo (-neda)
(provide
  (deftype coyo (value mapper)))

(setf coyo 'of (lambda (value)
                (coyo value identity)))

(setf coyo 'lift (lambda (value)
                  (cond ((not (exists? value))
                         (error! "(coyo.lift)" *e-guard* value))
                        :else (coyo.of value))))

(defmethod coyo to-string ()
  (let ((value (getf this 'value))
        (fn (getf this 'mapper)))
    (+ "(coyo " (show value) " " (show fn) ")")))

(defmethod coyo map (mapper)
  (cond ((not (function? mapper))
         (error! "(coyo.map)" *e-arg-1* "function, got " (show mapper)))
        :else (let ((value (getf this 'value))
                    (run-self (getf this 'mapper)))
                (coyo value (lambda (arg) (mapper (run-self arg)))))))

(defmethod coyo lower ()
  (let ((mapper (getf this 'mapper))
        (value (getf this 'value)))
    (cond ((not (function? mapper))
           (error! "(coyo.lower) requires the coyo:mapper property
                   to hold a function, but it holds " (show mapper)))
          ((not (exists? value))
           (error! "(coyo.lower) requires the coyo:value property
                   to hold a non (void) or (nil) value, but it holds "
                   (show value)))
          ((not (method? value map))
           (error! "(coyo.lower) requires the coyo:value property
                   to implement the functor typeclass but it doesn't"))
          :else (coyo (.map value mapper) identity))))

(defmethod coyo reduce (reducer seed)
  (let ((value (getf this 'value))
        (mapper (getf this 'mapper)))
    (cond ((not (function? reducer))
           (error! "(coyo.reduce)" *e-arg-1* "function, got " (show reducer)))
          ((not (defined? seed))
           (error! "(coyo.reduce)" *e-arg-2* "non (void) value, got " (show seed)))
          ((method? value reduce)
           (.reduce value
                    (lambda (acc val)
                      (reducer acc (mapper val)))
                    seed))
          :else (reducer seed (mapper value)))))



;; --- free
(provide
  (defsum free ((result value)
                (compute value run))))

(setf free 'of (lambda (value)
                (free.result value)))

(setf free 'lift (lambda (type)
                  (free.compute type free.result)))

(defmethod free map (f)
  (cond ((not (function? f))
         (error! "(free.map)" *e-arg-1* "function, got " (show f)))
        :else (.match this (hash :result (#(value)
                                          (free.result (f value)))
                                 :compute (#(value run)
                                            (free.compute value
                                                          (#(x) (.map (run x) f))))))))

(defmethod free ap (t-free)
  (cond ((not (method? t-free map))
         (error! "(free.ap)" *e-arg-1* "functor, got " (show t-free)))
        :else (.match this (hash :result (#(value)
                                          (.map t-free value))
                                 :compute (#(value run)
                                            (free.compute value
                                                          (#(x) (.ap (run x) t-free))))))))

(defmethod free flat-map (f)
  (cond ((not (function? f))
         (error! "(free.flat-map | free.chain)" *e-arg-1* "function, got " (show f)))
        :else (.match this (hash :result (#(value) (f value))
                                 :compute (#(value run)
                                            (free.compute value
                                                          (#(x) (.flat-map (run x) f))))))))

(setf free 'prototype 'chain (getf free 'prototype 'flat-map))

(defmethod free fold-map (f pointed)
  (cond ((not (function? f))
         (error! "(free.fold-map | free.interpret)" *e-arg-1* "function, got " (show f)))
        ((not (function? (getf pointed 'of)))
         (error! "(free.fold-map | free.interpret)" *e-arg-2* "Pointed, got " (show pointed)))
        :else (.match this (hash :result (#(value) (pointed.of value))
                                 :compute (#(value run)
                                            (ternary (nothing? value)
                                                     (.fold-map (run) f pointed)
                                                     (pipe 
                                                      (f value)
                                                      (.flat-map (#(x)
                                                                  (.fold-map (run x) 
                                                                             f 
                                                                             pointed))))))))))

(setf free 'prototype 'interpret (getf free 'prototype 'fold-map))

;; --- io
(provide
  (deftype io (unsafe-perform)))

(setf io 'of (lambda (value)
              (io (lambda () value))))

(setf io 'lift (lambda (value)
                (cond ((not (exists? value))
                       (error! "(io.lift)" *e-guard* value))
                      ((function? value)
                       (io value))
                      :else (io.of value))))

(setf io 'empty (lambda ()
                 (io (lambda (value) value))))

(setf io 'identity (getf io 'empty))

(defmethod io to-string ()
  (let ((fn (getf this 'unsafe-perform)))
    (+ "(io " (show fn)) ")"))

(defmethod io equals (t-io)
  (cond ((not (.is io t-io))
         (error! "(io.equals)" *e-arg-1* "io, got " (show t-io)))
        :else (eql? (getf this 'unsafe-perform)
                    (getf t-io 'unsafe-perform))))

(defmethod io concat (t-io)
  (cond ((not (.is io t-io))
         (error! "(io.concat)" *e-arg-1* "io, got " (show t-io)))
        :else (let ((run-self (getf this 'unsafe-perform))
                    (run-that (getf t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (run-that
                        (run-self arg)))))))

(defmethod io map (mapper)
  (cond ((not (function? mapper))
         (error! "(io.map)" *e-arg-1* "function, got " (show mapper)))
        :else (let ((run-self (getf this 'unsafe-perform)))
                (io (lambda (arg)
                      (mapper (run-self arg)))))))

(defmethod io contramap (pre-mapper)
  (cond ((not (function? pre-mapper))
         (error! "(io.contramp)" *e-arg-1* "function, got " (show pre-mapper)))
        :else (let ((run-self (getf this 'unsafe-perform)))
                (io (lambda (arg)
                      (run-self (pre-mapper arg)))))))

(defmethod io promap (pre-mapper post-mapper)
  (cond ((not (function? pre-mapper))
         (error! "(io.promap)" *e-arg-1* "function, got " (show pre-mapper)))
        ((not (function? post-mapper))
         (error! "(io.promap)" *e-arg-2* "function, got " (show post-mapper)))
        :else (let ((run-self (getf this 'unsafe-perform)))
                (io (lambda (arg)
                      (post-mapper (run-self (pre-mapper arg))))))))

(defmethod io ap (t-io)
  (cond ((not (.is io t-io))
         (error! "(io.ap)" *e-arg-1* "io, got " (show t-io)))
        :else (let ((run-self (getf this 'unsafe-perform)))
                (.map t-io run-self))))

(defmethod io flat-map (to-io-mapper)
  (cond ((not (function? to-io-mapper))
         (error! "(io.flat-map | io.chain)" *e-arg-1* "io returning function, got " (show to-io-mapper)))
        :else (let ((run-self (getf this 'unsafe-perform)))
                (io (lambda (arg)
                      (.unsafe-perform (to-io-mapper (run-self arg)) arg))))))

(setf io 'prototype 'chain (getf io 'prototype 'flat-map))

(defmethod io compose (t-io)
  (cond ((not (.is io t-io))
         (error! "(io.compose)" *e-arg-1* "io, got " (show t-io)))
        :else (let ((run-self (getf this 'unsafe-perform))
                    (run-that (getf t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (run-that
                        (run-self arg)))))))

(defmethod io run-io (arg)
  (.unsafe-perform this arg))
      



;; --- maybe
(provide
  (defsum maybe ((nothing) (just value))))

(setf maybe 'of (lambda (value)
                 (maybe.just value)))

(setf maybe 'lift (lambda (value)
                   (cond ((not (exists? value))
                          (maybe.nothing))
                         :else (maybe.of value))))

(setf maybe 'empty (lambda () (maybe.nothing)))

(setf maybe 'zero (lambda () (maybe.nothing)))

(defmethod maybe to-string ()
  (.match this (hash nothing (lambda () 
                               "(maybe.nothing)")
                     just (lambda (value)
                            (+ "(maybe.just " (show value) ")")))))

(defmethod maybe equals (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.equals)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda ()
                          (.match t-maybe
                                  (hash nothing (lambda () true)
                                        just (lambda () false))))
                just (lambda (value)
                      (.match t-maybe 
                              (hash nothing (lambda ()
                                              false)
                                    just (lambda (t-value)
                                           (if (method? value equals)  
                                               (.equals value t-value)
                                               (eql? value t-value)))))))))

(defmethod maybe concat (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.concat)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda ()
                          (maybe.nothing))
                just (lambda (value)
                       (.match t-maybe
                               (hash nothing (lambda () t-maybe)
                                     just (lambda (t-value)
                                            (let ((cnt (getf value 'concat)))
                                              (when (not (function? cnt))
                                                (error! "(maybe.concat) can only concat when both of the carried values implement the semigroup typeclass"))
                                              (.call cnt value t-value)))))))))

(defmethod maybe map (mapper)
  (cond ((not (function? mapper))
         (error! "(maybe.map)" *e-arg-1* "function, got " (show mapper)))
        :else (.match this 
                      (hash nothing (lambda ()
                                      (maybe.nothing))
                            just (lambda (value) 
                                  (maybe.lift (mapper value))))))) 

(defmethod maybe ap (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.ap)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda () 
                          (maybe.nothing))
                just (lambda (value)
                      (.map t-maybe value)))))

(defmethod maybe flat-map (to-maybe-mapper)
  (cond ((not (function? to-maybe-mapper))
         (error! "(maybe.flat-map|maybe.chain)" *e-arg-1* "function, got " (show to-maybe-mapper)))
        :else (.match this
                      (hash nothing (lambda ()
                                      (maybe.nothing))
                            just (lambda (value)
                                  (to-maybe-mapper value))))))

(setf maybe 'prototype 'chain (getf maybe 'prototype 'flat-map))

(defmethod maybe bimap (transform-nothing transform-just)
  (cond ((not (function? transform-nothing))
         (error! "(maybe.bimap)" *e-arg-1* "function, got " (show transform-nothing)))
        ((not (function? transform-just))
         (error! "(maybe.bimap)" *e-arg-2* "function, got " (show transform-just)))
        :else (.match this
                      (hash nothing (lambda () (transform-nothing))
                            just (lambda (value) (transform-just value))))))

(defmethod maybe alt (t-maybe)
  (cond ((not (.is maybe t-maybe))
         (error! "(maybe.alt)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
        :else (.match this
                      (hash nothing (lambda () t-maybe)
                            just (lambda (value) (maybe.just value))))))

(defmethod maybe reduce (reducer seed)
  (cond ((not (function? reducer))
         (error! "(maybe.reduce)" *e-arg-1* "function, got " (show reducer)))
        ((not (defined? seed))
         (error! "(maybe.reduce)" *e-arg-2* "non (void) value, got " (show seed)))
        :else (.match this
                      (hash nothing (lambda () seed)
                            just (lambda (value) (reducer seed value))))))

(defmethod maybe traverse (lift transformer)
  (cond ((not (function? lift))
         (error! "(maybe.traverse)" *e-arg-1* "function, got " (show lift)))
        (not (function? transformer)
         (error! "(maybe.traverse)" *e-arg-2* "function, got " (show transformer)))
        :else (.match this
                      (hash nothing (lambda () 
                                      (lift (maybe.nothing)))
                            just (lambda (value)
                                  (.map (transformer value) maybe.of))))))

(defmethod maybe sequence (lift)
  (cond ((not (function? lift))
         (error! "(maybe.sequence)" *e-arg-1* "function, got " (show lift)))
        :else (.traverse this lift identity)))



;;; --- transformer
(provide
  (defun maybe-transformer (t)
    (deftype maybe-t (stack))
    (when (not (function? t))
      (error! "(maybe-transformer)" *e-arg-1* "function, got " (show t)))
    (setf maybe-t 'lift (lambda (v)
                          (cond ((function? (getf t 'lift))
                                 (maybe-t (t.lift (maybe.lift v))))
                                ((funtion? (getf t 'of))
                                 (maybe-t (t.of (maybe.lift v))))
                                :else (error! "(maybe-t.lift) cannot stack with " (getf t 'name)))))
    (defmethod maybe-t map (mapper)
      (cond ((not (function? mapper))
             (error! "(maybe-transformer.map)" *e-arg-1* "function, got " (show mapper)))
            :else (maybe-t (.map (getf this 'stack)
                              (lambda (tt)
                                (.map tt mapper))))))
    (defmethod maybe-t flat-map (to-maybe-mapper)
      (cond ((not (function? to-maybe-mapper))
             (error! "(maybe-transformer.flat-map/chain)" 
                      *e-arg-1* 
                      "function, got " 
                      (show to-maybe-mapper)))
            :else (maybe-t (.flat-map 
                              (getf this 'stack)
                              (lambda (tt)
                                (.flat-map tt
                                           (lambda (v)
                                            (|> (to-maybe-mapper v)
                                                (getf 'stack)))))))))
    (setf maybe-t 'prototype 'chain (getf maybe-t 'prototype 'flat-map))
    maybe-t))



;; --- either
(provide
  (defsum either ((left error)
                  (right value))))

(setf either 'of (lambda (value)
                  (either.right value)))

(setf either 'lift (lambda (value is-left?)
                    (cond ((not (exists? value))
                           (either.left (error "")))
                          ((or (error? value) is-left?)
                           (either.left value))
                          :else (either.of value))))

(setf either 'empty (lambda ()
                     (either.right (list))))

(setf either 'zero (lambda ()
                    (either.left (error "either-zero"))))

(defmethod either to-string ()
  (.match this 
          (hash left (lambda (error) (+ "(either.left " (show error) ")")) 
                right (lambda (value) (+ "(either.right " (show value) ")")))))

(defmethod either equals (t-either)
  (cond ((not (.is either t-either))
         (error! "(either.equals)" *e-arg-1* "instance of either, got " (show t-either)))
        :else (.match this
                      (hash left (lambda ()
                                  (.match t-either
                                          (hash left (lambda () true)
                                                right (lambda () false))))
                            right (lambda (value)
                                    (.match t-either 
                                            (hash left (lambda () false)
                                                  right (lambda (t-value)
                                                          (ternary 
                                                            (method? value equals)  
                                                            (.equals value t-value)
                                                            (eql? value t-value))))))))))

(defmethod either concat (t-either)
  (cond ((not (.is either t-either))
         (error! "(either.concat)" *e-arg-1* "either, got " (show t-either)))
        :else (.match this
                      (hash left (lambda (error) (either.left error))
                            right (lambda (value)
                                    (.match t-either
                                            (hash left (lambda () t-either)
                                                  right (lambda (t-value)
                                                          (let ((cnt (getf value 'concat)))
                                                            (when (not (function? cnt))
                                                              (error! "(either.concat) cannot concat when both of the carried values implement the semigroup typeclass"))
                                                            (.call cnt value t-value))))))))))

(defmethod either map (mapper)
  (cond ((not (function? mapper))
         (error! "(either.map)" *e-arg-1* "function, got " (show mapper)))
        :else (.match this 
                      (hash left (lambda (error)
                                  (either.left error))
                            right (lambda (value) 
                                   (either.lift (mapper value))))))) 

(defmethod either ap (t-either)
  (when (not (.is either t-either))
    (error! "(either.ap)" *e-arg-1* "instance of either, got " (show t-either)))
  (.match this
          (hash left (lambda (error) 
                      (either.left error))
                right (lambda (value)
                       (.map t-either value)))))

(defmethod either flat-map (to-either-mapper)
  (cond ((not (function? to-either-mapper))
         (error! "(either.flat-map|either.chain)" *e-arg-1* "function, got " (show to-either-mapper)))
        :else (.match this
                      (hash left (lambda (error)
                                  (either.left error))
                            right (lambda (value)
                                   (to-either-mapper value))))))

(setf either 'prototype 'chain (getf either 'prototype 'flat-map))

(defmethod either bimap (transform-left transform-right)
  (cond ((not (function? transform-left))
         (error! "(either.bimap)" *e-arg-1* "function, got " (show transform-left)))
        ((not (function? transform-right))
         (error! "(either.bimap)" *e-arg-2* "function, got " (show transform-right)))
        :else (.match this
                      (hash left (lambda (error) (transform-left error))
                            right (lambda (value) (transform-right value))))))

(defmethod either alt (t-either)
  (cond ((not (.is either t-either))
         (error! "(either.alt)" *e-arg-1* "instance of either, got " (show t-either)))
        :else (.match this
                      (hash left (lambda () t-either)
                            right (lambda (value) (either.right value))))))

(defmethod either reduce (reducer seed)
  (cond ((not (function? reducer))
         (error! "(either.reduce)" *e-arg-1* "function, got " (show reducer)))
        ((not (defined? seed))
         (error! "(either.reduce)" *e-arg-2* "non (void) value, got " (show seed)))
        :else (.match this
                      (hash left (lambda () seed)
                            right (lambda (value) (reducer seed value))))))

(defmethod either traverse (lift transformer)
  (cond ((not (function? lift))
         (error! "(either.traverse)" *e-arg-1* "function, got " (show lift)))
        ((not (function? transformer))
         (error! "(either.traverse)" *e-arg-2* "function, got " (show transformer)))
        :else (.match this
                      (hash left (lambda (error) 
                                  (lift (either.left error)))
                            right (lambda (value)
                                   (.map (transformer value) either.of))))))

(defmethod either sequence (lift)
  (cond ((not (function? lift))
         (error! "(either.sequence)" *e-arg-1* "function, got " (show lift)))
        :else (.traverse this lift identity)))



;;; --- transformer
(provide
  (defun either-transformer (t)
    (deftype either-t (stack))
    (when (not (function? t))
      (error! "(either-transformer)" *e-arg-1* "function, got " (show t)))
    (setf either-t 'lift (lambda (v)
                          (cond ((function? (getf t 'lift))
                                 (either-t (t.lift (either.lift v))))
                                ((funtion? (getf t 'of))
                                 (either-t (t.of (either.lift v))))
                                :else (error! "(either-t.lift) cannot stack with " (getf t 'name)))))
    (defmethod either-t map (mapper)
      (cond ((not (function? mapper))
             (error! "(either-transformer.map)" *e-arg-1* "function, got " (show mapper)))
            :else (either-t (.map (getf this 'stack)
                              (lambda (tt)
                                (.map tt mapper))))))
    (defmethod either-t flat-map (to-either-mapper)
      (cond ((not (function? to-either-mapper))
             (error! "(either-transformer.flat-map/chain)" 
                      *e-arg-1* 
                      "function, got " 
                      (show to-either-mapper)))
            :else (either-t (.flat-map 
                              (getf this 'stack)
                              (lambda (tt)
                                (.flat-map tt
                                           (lambda (v)
                                            (|> (to-either-mapper v)
                                                (getf 'stack)))))))))
    (setf either-t 'prototype 'chain (getf either-t 'prototype 'flat-map))
    either-t))



;; --- seq
(provide
  (deftype seq (ls)))

(setf seq 'of (lambda (...values)
                (seq values)))

(setf seq 'lift (lambda (value)
                  (cond ((nothing? value)
                         (seq.empty))
                        ((list? value)
                         (seq value))
                        ((or (mset? value)
                             (and (exists? (getf value 'length))
                                  (not (function? value))))
                         (seq (as-list value)))
                        ((generator? value)
                         (seq (as-list (value))))
                        :else (seq (list value)))))

(setf seq 'empty (lambda ()
                  (seq (list))))

(defmethod seq to-string ()
  (+ "(seq " (show (getf this 'ls)) ")"))

(defmethod seq length ()
  (getf this 'ls 'length))

(defmethod seq concat (t-seq)
  (cond ((not (.is seq t-seq))
         (error! "(seq.concat)" *e-arg-1* "instance of seq, got " (show t-seq)))
        :else (let ((ls (getf this 'ls))
                    (ks (getf t-seq 'ls)))
                (seq (.concat ls ks)))))

(defmethod seq map (f)
  (cond ((not (function? f))
         (error! "(seq.map)" *e-arg-1* "function, got " (show f)))
        :else (seq (.map (getf this 'ls) f))))

(defmethod seq flat-map (f)
  (cond ((not (function? f))
         (error! "(seq.flat-map|seq.chain)" *e-arg-1* "function, got " (show f)))
        :else (seq (.flat-map (getf this 'ls)
                              (lambda (v)
                                (getf (f v) 'ls))))))

(setf seq 'chain (getf seq 'flat-map))

(defmethod seq ap (t-seq)
  (cond ((not (.is seq t-seq))
         (error! "(seq.ap)" *e-arg-1* "instance of seq, got " (show t-seq)))
        :else (seq (.flat-map (getf this 'ls)
                              (lambda (f)
                                (|> (.map t-seq f)
                                    (getf 'ls)))))))

(defmethod seq reduce (reducer seed)
  (cond ((not (function? reducer))
         (error! "(seq.reduce)" *e-arg-1* "function, got " (show reducer)))
        ((not (exists? seed))
         (error! "(seq.reduce)" *e-arg-2* "non-nil value, got " (show seed)))
        :else (.reduce (getf this 'ls) reducer seed)))

(defmethod seq fold-map (lift-map)
  (cond ((not (function? lift-map))
         (error! "(seq.fold-map)" *e-arg-1* "function, got " (show lift-map)))
        :else (.reduce (getf this 'ls)
                       (lambda (a x)
                        (ternary (nil? a)
                                 (lift-map x)
                                 (.concat a (lift-map x))))
                       (nil))))

(defmethod seq fold (lift)
  (cond ((not (function? lift))
         (error! "(seq.fold)" *e-arg-1* "function, got" (show lift)))
        :else (.reduce (getf this 'ls)
                       (lambda (a x)
                        (ternary (nil? a)
                                 (lift x)
                                 (.concat a (lift x))))
                       (nil))))

(defmethod seq traverse (lift transformer)
  (cond ((not (function? lift))
         (error! "(seq.traverse)" *e-arg-1* "function, got " (show lift)))
        ((not (function? transformer))
         (error! "(seq.traverse)" *e-arg-2* "function, got " (show transformer)))
        :else (.reduce (getf this 'ls)
                       (lambda (a x)
                        (|> (transformer x)
                            (.map (lambda (v)
                                    (lambda (w)
                                      (.concat w v))))
                            (.ap a)))
                       (lift (seq.empty)))))
        
(defmethod seq sequence (lift)
  (cond ((not (function? lift))
         (error! "(seq.sequence)" *e-arg-1* "function, got " (show lift)))
        :else (.traverse this lift (lambda (x) x))))


;; --- proof
(provide
  (defsum proof ((falsy errors)
                 (truthy value))))

(setf proof 'of (lambda (value)
                 (proof.truthy value)))

(setf proof 'lift (lambda (value is-falsy?)
                   (cond ((nothing? value)
                          (proof.falsy (list (error *e-no-value*))))
                         ((or (error? value) is-falsy?)
                          (proof.falsy (list value)))
                         :else (proof.truthy value))))

(setf proof 'empty (lambda ()
                    (proof.truthy true)))

(setf proof 'zero (lambda ()
                   (proof.falsy (list (error "ProofZero")))))

(defmethod proof to-string ()
  (.match this
          (hash truthy (lambda (value) (+ "(proof.truthy " (show value) ")"))
                falsy (lambda (errors) (+ "(proof.falsy " (show errors) ")"))))) 

(defmethod proof equals (t-proof)
  (cond ((not (.is proof t-proof))
         (error! "(proof.equals)" *e-arg-1* "instance of proof, got " (show t-proof)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (.match t-proof
                                            (hash truthy (lambda (t-value)
                                                          (equals value t-value))
                                                  falsy (lambda () false))))
                            falsy (lambda (errors)
                                    (.match t-proof
                                            (hash truthy (lambda () false)
                                                  falsy (lambda (t-errors)
                                                          (.every errors
                                                                  (lambda (e i)
                                                                    (equals e
                                                                            (getf t-errors i))))))))))))

(defmethod proof concat (t-proof)
  (cond ((not (.is proof t-proof))
         (error! "(proof.concat)" *e-arg-1* "proof, got " (show t-proof)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (.match t-proof
                                            (hash truthy (lambda (t-value)
                                                          (proof.truthy t-value))
                                                  falsy (lambda (errors)
                                                          (proof.falsy errors)))))
                            falsy (lambda (errors)
                                    (.match t-proof
                                            (hash truthy (lambda ()
                                                          (proof.falsy errors))
                                                  falsy (lambda (t-errors)
                                                          (proof.falsy 
                                                            (.concat errors
                                                                     t-errors))))))))))

(defmethod proof map (mapper)
  (cond ((not (function? mapper))
         (error! "(proof.map)" *e-arg-1* "function, got " (show mapper)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (proof.lift (mapper value)))
                            falsy (lambda (errors)
                                    (proof.falsy errors))))))

(defmethod proof flat-map (to-proof-mapper)
  (cond ((not (function? to-proof-mapper))
         (error! "(proof.flat-map/chain)"))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (to-proof-mapper value))
                            falsy (lambda (errors)
                                    (proof.falsy errors))))))

(setf proof 'prototype 'chain (getf proof 'prototype 'flat-map))
                    
(defmethod proof bimap (lhs-mapper rhs-mapper)
  (cond ((not (function? lhs-mapper))
         (error! "(proof.bimap)" *e-arg-1* "function, got " (show lhs-mapper)))
        ((not (function? rhs-mapper))
         (error! "(proof.bimap)" *e-arg-2* "function, got " (show rhs-mapper)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (proof.lift (rhs-mapper value)))
                            falsy (lambda (errors)
                                    (proof.falsy (.map errors lhs-mapper)))))))

(defmethod proof ap (t-proof)
  (cond ((not (.is proof t-proof))
         (error! "(proof.ap)" *e-arg-1* "proof, got " (show t-proof)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (.match t-proof
                                            (hash truthy (lambda (t-value)
                                                          (proof.lift (value t-value)))
                                                  falsy (lambda (t-errors)
                                                          (proof.falsy t-errors)))))
                            falsy (lambda (errors)
                                    (.match t-proof
                                            (hash truthy (lambda ()
                                                          (proof.falsy errors))
                                                  falsy (lambda (t-errors)
                                                          (proof.falsy 
                                                            (.concat errors 
                                                                     t-errors))))))))))

(defmethod proof alt (t-proof)
  (cond ((not (.is proof t-proof))
         (error! "(proof.alt)" *e-arg-1* "proof, got " (show t-proof)))
        :else (.match this
                      (hash truthy (lambda (value) (proof.truthy value))
                            falsy (lambda () t-proof)))))



;;; --- transformer
(provide
  (defun proof-transformer (t)
    (deftype proof-t (stack))
    (when (not (function? t))
      (error! "(proof-transformer)" *e-arg-1* "function, got " (show t)))
    (setf proof-t 'lift (lambda (v)
                          (cond ((function? (getf t 'lift))
                                 (proof-t (t.lift (proof.lift v))))
                                ((funtion? (getf t 'of))
                                 (proof-t (t.of (proof.lift v))))
                                :else (error! "(proof-t.lift) cannot stack with " (getf t 'name)))))
    (defmethod proof-t map (mapper)
      (cond ((not (function? mapper))
             (error! "(proof-transformer.map)" *e-arg-1* "function, got " (show mapper)))
            :else (proof-t (.map (getf this 'stack)
                                 (lambda (tt)
                                  (.map tt mapper))))))
    (defmethod proof-t flat-map (to-proof-mapper)
      (cond ((not (function? to-proof-mapper))
             (error! "(proof-transformer.flat-map/chain)" 
                      *e-arg-1* 
                      "function, got " 
                      (show to-proof-mapper)))
            :else (proof-t (.map (getf this 'stack)
                                 (lambda (tt)
                                  (.flat-map tt
                                             (lambda (v)
                                              (|> (to-proof-mapper v)
                                                  (getf 'stack)))))))))
    (setf proof-t 'prototype 'chain (getf proof-t 'prototype 'flat-map))
    proof-t))



;; --- task
(provide
  (deftype task (run-task)))

(setf task 'of (lambda (value)
                (task (lambda (fail ok)
                        (ok value)))))

(setf task 'zero (lambda (value)
                    (task (lambda (fail)
                            (fail
                              (ternary (error? value)
                                       value
                                       (error "TaskZero" value)))))))

(setf task 'lift (lambda (value)
                  (task (lambda (fail ok)
                          (cond ((or (nothing? value)
                                     (error? value))
                                 (fail value))
                                :else (ok value))))))
                                           
(setf task 'empty (lambda ()
                    (task (lambda (fail ok)))))

(setf task 'resolve (getf task 'of))

(setf task 'reject (getf task 'zero))

(defmethod task to-string ()
  "(task)") 

(defmethod task concat (t-task)
  (cond ((not (.is task t-task))
         (error! "(task.concat)" *e-arg-1* "instance of task, got " (show t-task)))
        :else (let ((run-self (getf this 'run-task))
                    (run-that (getf t-task 'run-task)))
                (task
                  (lambda (fail ok)
                    (let* ((done false)
                           (guard (lambda (f)
                                    (lambda (g)
                                      (when (not done)
                                        (assign done true)
                                        (f g))))))
                      (run-self (guard fail) (guard ok))
                      (run-that (guard fail) (guard ok))))))))

(defmethod task ap (t-task)
  (cond ((not (.is task t-task))
         (error! "(task.ap)" *e-arg-1* "instance of task, got " (show t-task)))
        :else (let ((run-self (getf this 'run-task))
                    (run-that (getf t-task 'run-task)))
                (task
                  (lambda (fail ok)
                    (let* ((adone false)
                           (bdone false)
                           (aval false)
                           (bval false)
                           (rejected false)
                           (rej (lambda (v)
                                  (when (not rejected)
                                    (assign rejected true)
                                    (fail v))))
                           (res (lambda (f)
                                  (lambda (v)
                                    (when (not rejected)
                                      (f v)
                                      (if (and adone bdone)
                                          (ok (call aval bval))
                                          v))))))
                      (run-self rej (res (lambda (a)
                                          (assign adone true)
                                          (assign aval a))))
                      (run-that rej (res (lambda (b)
                                          (assign bdone true)
                                          (assign bval b))))))))))

(defmethod task map (mapper)
  (cond ((not (function? mapper))
         (error! "(task.map)" *e-arg-1* "function, got " (show mapper)))
        :else (let ((run (getf this 'run-task)))
                (task (lambda (fail ok)
                        (run fail (lambda (value)
                                    (ok (mapper value)))))))))

(defmethod task flat-map (to-task-mapper)
  (cond ((not (function? to-task-mapper))
         (error! "(task.flat-map)" *e-arg-1* "function, got " (show to-task-mapper)))
        :else (let ((run (getf this 'run-task)))
                (task (lambda (fail ok)
                        (run fail (lambda (value)
                                    (.run-task (to-task-mapper value) fail ok))))))))

(setf task 'prototype 'chain (getf task 'prototype 'flat-map))

(defmethod task bimap (lhs-mapper rhs-mapper)
  (cond ((not (function? lhs-mapper))
         (error! "(task.bimap)" *e-arg-1* "function, got " (show lhs-mapper)))
        ((not (function? rhs-mapper))
         (error! "(task.bimap)" *e-arg-2* "function, got " (show rhs-mapper)))
        :else (let ((run (getf this 'run-task)))
                (task (lambda (fail ok)
                        (run (lambda (exc)
                              (fail (lhs-mapper exc)))
                             (lambda (value)
                              (ok (rhs-mapper value)))))))))

(defmethod task alt (t-task)
  (cond ((not (.is task t-task))
         (error! "(task.alt)" *e-arg-1* "instance of task, got " (show t-task)))
        :else (let ((run-self (getf this 'run-task))
                    (run-that (getf t-task 'run-task)))
                (task (lambda (fail ok)
                        (run-self (lambda () (run-that fail ok))
                                  ok))))))




;;; DATA STRUCTURE COERCIONS
(provide
  (defun coyo-as-maybe (cyo)
    (.reduce cyo 
             (#(_ v) (maybe.lift v)) 
             (nil))))

(provide
  (defun coyo-as-either (cyo)
    (.reduce cyo 
             (#(_ v) (either.lift v)) 
             (nil))))

(provide
  (defun coyo-as-io (cyo)
    (.reduce cyo 
             (#(_ v) (io.lift v))
             (nil))))

(provide
  (defun coyo-as-task (cyo)
    (.reduce cyo 
             (#(_ v) (task.lift v))
             (nil))))

(provide
  (defun coyo-as-proof (cyo)
    (.reduce cyo 
             (#(_ v) (proof.lift v))
             (nil))))

(provide
  (defun maybe-as-either (mbe)
    (.match mbe (hash :nothing either.zero
                      :just either.lift))))

(provide
  (defun maybe-as-proof (mbe)
    (.match mbe (hash :nothing proof.zero
                      :just proof.lift))))

(provide
  (defun maybe-as-task (mbe)
    (.match mbe (hash :nothing task.zero
                      :just task.lift))))

(provide
  (defun either-as-maybe (eth)
    (.match eth (hash :left maybe.zero
                      :right maybe.lift))))

(provide
  (defun either-as-proof (eth)
    (.match eth (hash :left (#(e) (proof.lift e true))
                      :right proof.lift))))

(provide
  (defun either-as-task (eth)
    (.match eth (hash :left task.zero
                      :right task.lift))))

(provide
  (defun proof-as-maybe (prf)
    (.match prf (hash :falsy maybe.zero
                      :truthy maybe.lift))))

(provide
  (defun proof-as-either (prf)
    (.match prf (hash :falsy (lambda (errs) (either.left (first errs)))
                      :truthy either.lift))))

(provide
  (defun proof-as-task (prf)
    (.match prf (hash :falsy (pipe-thunk
                               (.reduce (#(a e) (+ a (getf e 'message) "\n")) "")
                               (error)
                               (task.zero))
                      :truthy task.lift))))

(provide
  (defun io-as-task (eff ...args)
    (task (#(fail ok))
      (try (ok (.run eff ...args))
           (fail (error "Failed to run " eff))))))

