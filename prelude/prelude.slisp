(comment sibilisp-prelude - MIT)

;;;;                  PRELUDE - README
;;;; --------------------------------------------
;;;; This file contains definitions for all the functions that 
;;;; are parts of sibilisp's prelude. It uses a modified syntax
;;;; of Hindley-Milner type notation to describe it's included
;;;; function's arguments and outputs.
;;;; Here's a short description:
;;;; - Specified types are written with their respective constructor
;;;;    Example: String, Boolean
;;;; - Abstract types are written as lowercase symbols
;;;;   Example: a, b
;;;; - In case a type is ireelevant, the underscore is used in place
;;;;   Example: _
;;;; - Null is written as unit/nil/empty list
;;;;   Example: ()
;;;; - If a function requires multiple arguments at once, braces
;;;;   and commas are used
;;;;   Example: (String, String)
;;;; - Functions are written with arrow notation
;;;;   Example: (String, String) -> String
;;;; - Type classes are written in capital case symbols
;;;;   Example: Functor, Semigroup
;;;; - Type restrictions for type classes may be added to functions
;;;;   Example: Functor F. (F a, (a -> b)) -> F b
;;;; - Lists may be written with square braces instead of the
;;;;   fully specified types
;;;;   Example (full specified): (List String Number)
;;;;   Example (appreviated): [String Number]
;;;; - Hashes may be written with curly braces instead of the
;;;;   fully specified types
;;;;   Example (full specified): (Hash :a Number)
;;;;   Example (appreviated): { :a Number }


;;; CONSTANTS
(defconstant *e-no-value* "E_NO_VALUE")
(defconstant *e-guard* " guards agains (nil) and (void) values, got")
(defconstant *e-arg-1* " expects argument 1 to be a ")
(defconstant *e-arg-2* " expects argument 2 to be a ")
(defconstant *e-arg-3* " expects argument 3 to be a ")

;;; BASIC LAMBDA OPERATORS (I, K, S)
(provide
  ;; identity :: a -> a
  (defun identity (a) a))

(provide
  ;; thunk :: a -> () -> a
  (defun thunk (a)
    (lambda () a)))


;;; LANGUAGE TYPE CHECK UTILITIES
(provide
  ;; list-of? :: ([_], (_ -> Boolean)) -> Boolean
  ;; --- (list-of? *items* (lambda (x) (string? x)))
  (defun list-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(list-of?)" *e-arg-2* "function, got " predicate))
          :else (and (list? x)
                     (.every x predicate)))))

(provide
  ;; hash-of? :: ({ :a _ }, (_ -> Boolean)) -> Boolean
  ;; --- (hash-of? *items* (lambda (x) (string? x)))
  (defun hash-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(hash-of?)" *e-arg-2* "function, got " predicate))
          :else (and (hash? x)
                     (.every (hash-pairs x) (lambda ([_ v]) (predicate v)))))))

(provide 
  ;; dict-of? :: ((Dict :a _), (_ -> Boolean)) -> Boolean
  ;; --- (dict-of? *items* (lambda (x) (string? x)))
  (defun dict-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(dict-of?)" *e-arg-2* "function, got " predicate))
          :else (and (dict? x)
                     (.every (.entries x) (lambda ([_ v]) (predicate v)))))))



;;; FUNCTION FUNCTIONS
(provide
  ;; converge :: (((a, b, ...) -> c), [(_ -> a), (_ -> b), ...]) -> ((_, _, ...) -> c)
  ;; --- (converge (lambda (prefix word)
  ;;                    (+ prefix "-" word))
  ;;                  (list (thunk "Hello")
  ;;                        (lambda (w) (.to-lower-case w))))
  (defun converge (combine branches)
    (cond ((not (function? combine))
           (error! "(converge)" *e-arg-1* "function, got " combine))
          ((not (list-of? branches (lambda (v) (function? v))))
           (error! "(converge)" *e-arg-2* "list of functions, got " branches))
          :else (lambda (...args)
                  (.apply combine
                          (nil)
                          (.map branches
                              (lambda (branch i)
                                (.apply branch (nil) args))))))))

(provide
  ;; memoize :: ((a, b, ...) -> c) -> ((a, b, ...) -> c)
  ;; --- (memoize (lambda ()))
  (defun memoize (compute)
    (cond ((not (function? compute))
           (error! "(memoize)" *e-arg-1* "function, got " compute))
          :else (let ((cache (dict)))
                  (lambda (...args)
                    (cond ((.has cache args)
                           (.get cache args))
                          :else (pipe cache
                                      (.set args (.apply compute (nil) args))
                                      (.get args)))))))) 
  


;;; GENERAL PURPOSE OPERATIONS
(provide
  ;; show :: a -> String
  (defun show (x)
    (cond ((eq? (nil) x)
           "(nil)")
          ((nan? x)
           "(nan)")
          ((error? x)
           (+ "(error " x.name ": " x.message ")"))
          ((string? x)
           (+ "(string " x ")"))
          ((number? x)
           (+ "(number " x ")"))
          ((function? x)
           (+ "(function " (or (getf x 'name) "lambda") ")"))
          ((generator? x)
           (+ "(generator " (getf x 'name) ")"))
          ((list? x)
           (+ "(list" 
              (.reduce x 
                       (lambda (a v)
                        (+ a " " (show v))) 
                       "")
              ")"))
          ((mset? x)
           (+ "(mset" 
              (.reduce (as-list x) 
                       (lambda (a v)
                        (+ a " " (show v)))
                       "")
              ")"))
          ((hash? x)
           (+ "(hash" (.reduce (hash-pairs x)
                               (lambda (a [k v])
                                (+ a " :" k " " (show v))) "") ")"))
          ((dict? x)
           (+ "(dict" (.reduce (.entries x)
                               (lambda (a [k v])
                                 (+ a " :" (show k) " " (show v)))
                               "") ")"))
          ((future? x)
           "(future)")
          ((date? x)
           (+ "(date" (.get-full-year x)
              "-" (+ 1 (.get-month x))
              "-" (.get-date x) ")"))
          ((regex? x)
           (+ "(regex " (getf x 'source) " :flags " (getf x 'flags) ")"))
          :else (.to-string x))))


(provide
  ;; equals :: (a, b) -> Boolean
  (defun equals (x y)
      (cond ((nil? x) (nil? y))
            ((void? x) (void? y))
            ((string? x y) (eql? x y))
            ((function? x y) (eql? x y))
            ((number? x y) (eql? x y))
            ((regex? x y) (and 
                            (eql? (getf x 'source)
                                  (getf y 'source))
                            (eql? (getf x 'flag)
                                  (getf y 'flag))))
            ((date? x y) (eql? (as-number x) (as-number y)))
            ((generator? x y) (eql? x y))
            ((future? x y) (eql? x y))
            ((list? x y) (and (eql? (length x)
                                    (length y))
                              (.every 
                                x
                                (lambda (va i)
                                  (equals va (getf y i))))))
            ((mset? x y) (and (eql? (.size x)
                                    (.size y))
                              (equals (as-list x)
                                      (as-list y))))
            ((hash? x y) (let ((pa (hash-pairs x))
                               (pb (hash-pairs y)))
                          (and (eql? (length pa) (length pb)) 
                               (.every 
                                pa
                                (lambda ([k v])
                                  (equals v (getf y k)))))))
            ((dict? x y) (let ((pa (dict-pairs x))
                               (pb (dict-pairs y)))
                          (and (eql? (length pa) (length pb))
                               (.every
                                pa
                                (lambda ([k v])
                                  (equals v (.get y k)))))))
            ((method? x equals) (.equals x y))
            :else false)))

(provide
  ;; concat :: Semigroup S. (S a, S a) -> S a
  ;; --- string, function, list, future, semigroupoid
  (defun concat (x y)
    (cond ((or (not (exists? x)) (not (exists? y)))
           (error! "(concat) cannot concatenate with a (void) or (nil) value"))
          ((string? x y) (+ x y))
          ((function? x y) (lambda (...args) (y (.apply x null args))))
          ((list? x y) (.concat x y))
          ((mset? x y) (mset-merge x y))
          ((future? x y) (future-all x y))
          ((method? x concat) (.concat x y))
          :else (error! "(concat) needs both arguments to be in the same semigroup"))))

(provide
  ;; map :: Functor F. (F a, (a -> b)) -> F b
  (defun map (x mapper)
    (cond ((not (exists? x))
           (error! "(map)" *e-guard* (show x)))
          ((not (function? mapper))
           (error! "(map)" *e-arg-1* "function, got " (show mapper)))
          ((function? x) (lambda (...args) (mapper (.apply x null args))))
          ((future? x) (.then x mapper identity))
          ((method? x map) (.map x mapper))
          ((hash? x)
           (.reduce (hash-pairs x)
                    (lambda (o [k v]) (hash-merge! o (hash k (mapper v))))
                    (hash)))
          ((dict? x)
           (let ((y (dict)))
            (each ([k v]) (dict-pairs x)
              (.set y k (mapper v)))
            y))
          ((mset? x)
           (let ((y (mset)))
            (each v x
              (.add y (mapper v)))
            y))
          :else (error! "(map) needs the value to be a Functor"))))

(provide
  ;; ap :: Functor F, Apply A. (F a, A (a -> b)) -> F b
  (defun ap (x applicable)
    (cond ((not (exists? x))
           (error! "(ap)" *e-guard* (show x)))
          ((not (or (exists? applicable)
                    (function? applicable)
                    (method? applicable ap)
                    (list? applicable)
                    (mset? applicable)))
           (error! "(ap)" *e-arg-2* "Apply, got " (show applicable)))
          ((function? x applicable)
           (lambda (...args)
            (call (applicable ...args) (x ...args) ...args)))
          ((future? x applicable)
           (.then applicable (lambda (f) (.then x f identity))))
          ((and (method? x map) (method? applicable ap))
           (.ap applicable x))
          ((list? x applicable)
           (.map x (lambda (v)
                    (.reduce applicable 
                             (lambda (y f)
                              (f y))
                             v))))
          ((mset? x applicable)
           (let ((y (mset)))
            (each v x
              (each f applicable
                (.add y (f v))))
            y))
          :else (error! "(ap) needs the value to be a Functor"))))

(provide
  ;; flat-map :: Chain C. (C a, (a -> C b)) -> C b
  (defun flat-map (x chain-mapper)
    (cond ((not (exists? x))
           (error! "(flat-map|chain)" *e-guard* (show x)))
          ((not (function? chain-mapper))
           (error! "(flat-map|chain)" *e-arg-2* "function, got " (show chain-mapper)))
          ((function? x)
           (lambda (...args)
            (call (chain-mapper (.apply x null args)) ...args)))
          ((future? x)
           (.then x chain-mapper identity))
          ((method? x flat-map)
           (.flat-map x chain-mapper))
          ((list? x)
           (.reduce x 
                    (lambda (ls v)
                      (.concat ls v))
                    (list)))
          :else (error! "(flat-map|chain) needs the value to be a Chain"))))

(provide
  (defconstant chain flat-map))

(provide
  ;; bimap :: BiFunctor B. (B a, (_ -> b), (a -> b)) -> B b
  ;; --- future, list, bifunctors
  (defun bimap (x lhs-mapper rhs-mapper)
    (cond ((not (exists? x))
           (error! "(bimap)" *e-guard* (show x)))
          ((not (function? lhs-mapper))
           (error! "(bimap)" *e-arg-2* "function, got " (show lhs-mapper)))
          ((not (function? rhs-mapper))
           (error! "(bimap)" *e-arg-3* "function, got " (show rhs-mapper)))
          ((future? x)
           (.then x rhs-mapper lhs-mapper))
          ((list? x)
           (ternary (< (length x) 1)
                    (list (lhs-mapper)) 
                    (.map x rhs-mapper)))
          ((mset? x)
           (ternary (< (getf x 'size) 1)
                    (mset (lhs-mapper))
                    (mset ...(.map (as-list x) rhs-mapper))))
          ((method? x bimap)
           (.bimap x lhs-mapper rhs-mapper))
          :else (error! "(bimap) needs the first argument to be a BiFunctor"))))

(provide
  ;; contramap :: 
  (defun contramap (x lhs-mapper)
    (bimap x lhs-mapper identity)))

(provide
  ;; promap :: ProFunctor P. (P a b, (c -> a), (b -> d)) -> P c d
  ;; --- function, profunctors
  (defun promap (x pre-mapper post-mapper)
    (cond ((not (exists? x))
           (error! "(promap)" *e-guard* (show x)))
          ((not (function? pre-mapper))
           (error! "(promap)" *e-arg-2* "function, got " (show pre-mapper)))
          ((not (function? post-mapper))
           (error! "(promap)" *e-arg-3* "function, got " (show post-mapper)))
          ((function? x)
           (lambda (...args)
            (post-mapper (x (.apply pre-mapper null args)))))
          ((method? x promap)
           (.promap x pre-mapper post-mapper))
          :else (error! "(promap) needs the first argument to be a ProFunctor"))))

(provide
  ;; reduce :: Foldable F. (F a, ((b a) -> b) -> *opt b -> b)
  ;; --- list, set
  (defun reduce (x reducer seed)
    (cond ((not (exists? x))
           (error! "(reduce)" *e-guard* (show x)))
          ((not (function? reducer))
           (error! "(reduce)" *e-arg-2* "function, got " (show reducer)))
          ((mset? x)
           (let ((y (mset-values x)))
            (.reduce y reducer seed)))
          ((method? x reduce)
           (.reduce x reducer seed))
          :else (error! "(reduce) needs the first argument to be a Foldable"))))

(provide
  (defun fold-map (x lift-map)
    (cond ((not (exists? x))
           (error! "(reduce)" *e-guard* (show x)))
          ((not (function? lift-map))
           (error! "(fold-map)" *e-arg-2* "function, got " (show lift-map)))
          ((mset? x)
           (let ((y (mset-values x)))
            (.reduce y
                     (lambda (a value)
                      (ternary (nil? a)
                               (lift-map value)
                               (.concat a (lift-map value))))
                     (nil))))
          ((method? x reduce)
           (.reduce x
                    (lambda (a value)
                      (ternary (nil? a)
                               (lift-map value)
                               (.concat a (lift-map value))))
                    (nil)))
          :else (error! "(fold-map) needs the first argument to be a Foldable"))))

(provide
  (defun fold (x lift)
    (cond ((not (function? lift))
           (error! "(fold)" *e-arg-2* "function, got " (show lift)))
          ((mset? x)
           (let ((y (mset-values x)))
            (.reduce y
                     (lambda (a value)
                      (ternary (nil? a)
                               (lift value)
                               (.concat a (lift value))))
                     (nil))))
          ((method? x fold)
           (.fold x lift))
          ((method? x reduce)
           (.reduce x
             (lambda (a value)
               (ternary (nil? a)
                        (lift value)
                        (.concat a (lift value))))
             (nil)))
          :else (error! "(fold) needs the first argument to be a Foldable"))))

(provide
  (defun traverse (x lift transformer)
    (cond ((not (exists? x))
           (error! "(traverse)" *e-arg-1* "Traversable, got " (show x)))
          ((not (function? lift))
           (error! "(traverse)" *e-arg-2* "function, got " (show lift)))
          ((not (function? transformer))
           (error! "(traverse)" *e-arg-3* "function, got " (show transformer)))
          ((mset? x)
           (let ((y (mset-values x)))
            (.reduce y
                     (lambda (a value)
                      (pipe 
                        (transformer value)
                        (.map (lambda (x)
                                (lambda (y)
                                  (mset-merge! y x))))
                        (.ap a)))
                     (lift (mset)))))
          ((list? x)
           (.reduce x
                    (lambda (a value)
                      (pipe
                        (transformer value)
                        (.map (lambda (x)
                                (lambda (y)
                                  (.concat y x))))
                        (.ap a)))
                    (lift (list))))
          ((method? x traverse)
           (.traverse x lift transformer))
          :else (error! "(traverse) needs the first argument to be a Traversable"))))

(provide
  (defun sequence (x lift)
    (cond ((not (exists? x))
           (error! "(sequence)" *e-arg-1* "Traversable, got " (show x)))
          ((not (function? lift))
           (error! "(sequence)" *e-arg-2* "function, got " (show lift)))
          ((mset? x)
           (let ((y (mset-values x)))
            (.reduce y
                     (lambda (a value)
                      (pipe
                        (.map value (lambda (x)
                                      (lambda (y)
                                        (mset-merge! y x))))
                        (.ap a)))
                     (lift (mset)))))
          ((list? x)
           (.reduce x
                    (lambda (a value)
                      (pipe
                        (.map value (lambda (x)
                                      (lambda (y)
                                        (.concat y x))))
                        (.ap a)))
                    (lift (list))))
          ((method? x sequence)
           (.sequence x lift transformer))
          :else (error! "(sequence) needs the first argument to be a Traversable"))))



;;; LIST/MSET RELATED

(provide
  (defun zip (ls-a ls-b)
    (cond ((list? ls-a ls-b)
           (let ((l (min (length ls-a) (length ls-b)))
                 (i 0)
                 (r (list)))
            (while (< i l)
              (.push r (list (getf ls-a i) (getf ls-b i)))
              (incr-by i 1))
            r))
          ((mset? ls-a ls-b)
           (let* ((a (as-list ls-a))
                  (b (as-list ls-b))
                  (l (min (length a) (length b)))
                  (i 0)
                  (r (mset)))
            (while (< i l)
              (.add r (list (getf a i) (getf b i)))
              (incr-by i 1))
            r))
          :else (error! "(zip) expects both arguments to be a list or mset"))))
            
(provide
  (defun unzip (ls)
    (cond ((or (list? ls) (mset? ls))
           (let ((ks (list))
                 (vs (list)))
            (each ([k v]) ls
              (.push ks k)
              (.push vs v))
            (list ks vs)))
          :else (error! "(unzip) expects the argument to be a list or mset"))))

(provide
  (defun find (ls predicate)
    (cond ((not (function? predicate))
           (error! "(find)" *e-arg-2* "function, got" (show predicate)))
          ((and (list? ls) (function? (getf ls 'find)))
           (maybe.lift (.find ls predicate)))
          ((list? ls)
           (let ((l (length ls))
                 (i 0)
                 (m (nil)))
            (while (and (not m) (< i l))
              (when (predicate (getf ls i))
                (assign m (getf ls i)))
              (incr-by i 1))
            (maybe.lift m)))
          ((mset? ls)
           (let ((x (as-list ls))
                 (l (length x))
                 (i 0)
                 (m (nil)))
            (while (and (not m) (< i l))
              (when (predicate (getf x i))
                (assign m (getf x i)))
              (incr-by i 1))
            (maybe.lift m)))
          :else (error! "(find) expects the first argument to be a list or mset"))))

(provide
  (defun filter (ls predicate)
    (cond ((not (function? predicate))
           (error! "(filter)" *e-arg-2* "function, got " (show predicate)))
          ((list? ls)
           (.filter ls predicate))
          ((mset? ls)
           (let ((x (as-list ls)))
            (mset (.filter ls predicate))))
          :else (error! "(filter) expects the first argument to be a list or mset"))))

(provide
  (defconstant select filter))

(provide
  (defun reject (ls predicate)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(reject) expects the first argument to be a list or mset"))
          ((not (function? predicate))
           (error! "(reject)" *e-arg-2* "function, got" (show predicate)))
          :else (filter ls (lambda (x) (not (predicate x)))))))

(provide
  (defun unique (ls)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(unique)" *e-arg-1* "list or mset, got" (show ls)))
          ((list? ls)
           (as-list (mset ...ls)))
          :else ls)))

(provide
  (defun union (ls-a ls-b)
    (cond ((not (or (list? ls-a ls-b) (mset? ls-a ls-b)))
           (error! "(union) expects the arguments to both be lists or msets"))
          ((list? ls-a ls-b)
           (let ((ab (.concat ls-a ls-b)))
            (as-list (mset ...ab))))
          :else (mset ...(as-list ls-a)
                      ...(as-list ls-b)))))

(provide
  (defun intersection (ls-a ls-b)
    (cond ((not (or (list? ls-a ls-b) (mset? ls-a ls-b)))
           (error! "(intersection) expects the arguments to both be lists or msets"))
          ((list? ls-a ls-b)
           (let ((a (unique ls-a))
                 (b (unique ls-b))
                 (ab (list)))
            (each v a
              (when (> (.index-of b v) -1)
                (.push ab v)))
            (each v b
              (when (> (.index-of a v) -1)
                (.push ab v)))
            ab))
          :else (let ((ab (mset)))
                  (each v ls-a
                    (when (.has b v)
                      (.add ab v)))
                  (each v ls-b
                    (when (.has a v)
                      (.add ab v)))
                  ab))))

(provide
  (defun difference (ls-a ls-b)
    (cond ((not (or (list? ls-a ls-b) (mset? ls-a ls-b)))
           (error! "(difference) expects the arguments to both be lists or msets"))
          ((list? ls-a ls-b)
           (let ((a (unique ls-a))
                 (b (unique ls-b))
                 (ab (list)))
            (each v a
              (when (< (.index-of b v) 0)
                (.push ab v)))
            (each v b
              (when (< (.index-of a v) 0)
                (.push ab v)))
            ab))
          :else (let ((ab (mset)))
                  (each v ls-a
                    (when (not (.has b v))
                      (.add ab v)))
                  (each v ls-b
                    (when (not (.has a v))
                      (.add ab v)))
                  ab))))

(provide
  (defun take (ls count)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(take)" *e-arg-1* "list or mset, got " (show ls)))
          ((not (number? count))
           (error! "(take)" *e-arg-2* "number, got " (show count)))
          ((list? ls)
           (ternary (<= count (length ls))
                    (.slice ls 0 count)
                    ls))
          :else (ternary (<= count (getf ls 'size))
                         (let* ((xs (as-list ls))
                                (ys (.slice xs 0 count)))
                          (mset ...ys))
                         ls))))

(provide
  (defun drop (ls count)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(drop)" *e-arg-1* "list or mset, got " (show ls)))
          ((not (number? count))
           (error! "(drop)" *e-arg-2* "number, got " (show count)))
          ((list? ls)
           (ternary (<= count (length ls))
                    (.slice ls count)
                    (list)))
          :else (ternary (<= count (getf ls 'size))
                         (let* ((xs (as-list ls))
                                (ys (.slice xs count)))
                          (mset ...ys))
                         (mset)))))

(provide
  (defun partition (ls count)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(partition)" *e-arg-1* "list or mset, got " (show ls)))
          ((not (number? count))
           (error! "(partition)" *e-arg-2* "number, got " (show count)))
          ((list? ls)
           (let ((xs (list)
                  (i 0)
                  (l (length ls))))
            (while (< i l)
              (let ((a (.slice ls i count)))
                (.push xs a)
                (incr-by i count)))
            xs))
          :else (let ((xs (as-list ls))
                      (ys (list))
                      (i 0)
                      (l (length xs)))
                  (while (< i l)
                    (let ((a (.slice xs i count)))
                      (.push ys a)
                      (incr-by i count)))
                  (mset ...ys)))))

(provide
  (defun partition-with (ls partitioner)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(partition-with)" *e-arg-1* "list or mset, got " (show ls)))
          ((not (function? partitioner))
           (error! "(partition-with)" *e-arg-2* "list or mset, got " (show ls)))
          ((list? ls)
           (.reduce ls
                    (#(acc a)
                      (cond ((nil? acc) (list (list a)))
                            ((not (partitioner a))
                             (let ((b (last acc)))
                              (.push b a)
                              acc))
                            :else (.concat acc (list (list a)))))
                    (nil)))
          :else (let ((xs (as-list ls)))
                  (mset ...(.reduce xs
                                    (#(acc x)
                                      (cond ((nil? acc) (list (list x)))
                                            ((not (partitioner a))
                                             (let ((b (last acc)))
                                               (.push b a)
                                               acc))
                                            :else (.concat acc (list (list x)))))
                                    (nil)))))))

;; (provide
;;   (defun sort-with (ls sorter)))

;; (provide
;;   (defun group-with (ls grouper)))

(provide
  (defun keep (ls)
    (cond ((not (or (list? ls) (mset? ls)))
           (error! "(keep)" *e-arg-1* "list or mset, got " (show ls)))
          ((list? ls)
           (.reduce ls
                    (#(acc a)
                      (ternary (and (exists? a) 
                                    (not (nan? a))) 
                               (.concat acc a) 
                               acc))
                    (list)))
          :else (let ((xs (as-list ls)))
                  (mset ...(.reduce xs
                                    (#(acc x)
                                      (ternary (and (exists? x)
                                                    (not (nan? x)))
                                               (.concat acc x)
                                               acc))
                                    (list)))))))



;;; HASH/DICT RELATED

(provide
  (defun get-key (obj ...prop-chain)
    (let ((x obj)
          (ps prop-chain)
          (i 0)
          (l (length ps)))
      (while (and (exists? x)
                  (< i l))
        (assign x (getf x (getf ps i)))
        (incr-by i 1))
      (maybe.lift x))))

(provide
  (defun pick-keys (ob ...prop-chains)
    (.reduce prop-chains
             (#(acc p-chain)
              (setf acc p-chain (get-key ob p-chain))
              acc)
             (hash-create))))



;;; ALGEBRAIC TYPES

;; --- coyo (-neda)
(provide
  (deftype coyo (value mapper)))

(setf coyo 'of (lambda (value)
                (coyo value identity)))

(setf coyo 'lift (lambda (value)
                  (cond ((not (exists? value))
                         (error! "(coyo.lift)" *e-guard* value))
                        :else (coyo.of value))))

(defmethod coyo to-string ()
  (let ((value (getf this 'value))
        (fn (getf this 'mapper)))
    (+ "(coyo " (show value) " " (show fn) ")")))

(defmethod coyo map (mapper)
  (cond ((not (function? mapper))
         (error! "(coyo.map)" *e-arg-1* "function, got " (show mapper)))
        :else (let ((value (getf this 'value))
                    (run-self (getf this 'mapper)))
                (coyo value (lambda (arg) (mapper (run-self arg)))))))

(defmethod coyo lower ()
  (let ((mapper (getf this 'mapper))
        (value (getf this 'value)))
    (cond ((not (function? mapper))
           (error! "(coyo.lower) requires the coyo:mapper property
                   to hold a function, but it holds " (show mapper)))
          ((not (exists? value))
           (error! "(coyo.lower) requires the coyo:value property
                   to hold a non (void) or (nil) value, but it holds "
                   (show value)))
          ((not (method? value map))
           (error! "(coyo.lower) requires the coyo:value property
                   to implement the functor typeclass but it doesn't"))
          :else (coyo (.map value mapper) identity))))

(defmethod coyo reduce (reducer seed)
  (let ((value (getf this 'value))
        (mapper (getf this 'mapper)))
    (cond ((not (function? reducer))
           (error! "(coyo.reduce)" *e-arg-1* "function, got " (show reducer)))
          ((not (defined? seed))
           (error! "(coyo.reduce)" *e-arg-2* "non (void) value, got " (show seed)))
          ((method? value reduce)
           (.reduce value
                    (lambda (acc val)
                      (reducer acc (mapper val)))
                    seed))
          :else (reducer seed (mapper value)))))


;; --- io
(provide
  (deftype io (unsafe-perform)))

(setf io 'of (lambda (value)
              (io (lambda () value))))

(setf io 'lift (lambda (value)
                (cond ((not (exists? value))
                       (error! "(io.lift)" *e-guard* value))
                      :else (io.of value))))

(setf io 'empty (lambda ()
                 (io (lambda (value) value))))

(setf io 'identity (getf io 'empty))

(defmethod io to-string ()
  (let ((fn (getf this 'unsafe-perform)))
    (+ "(io " (show fn) ")")))

(defmethod io equals (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.equals)" *e-arg-1* "io, got " (show t-io)))
        :else (eql? (getf this 'unsafe-perform)
                    (getf t-io 'unsafe-perform))))

(defmethod io concat (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.concat)" *e-arg-1* "io, got " (show t-io)))
        :else (let ((run-self (getf this 'unsafe-perform))
                    (run-that (getf t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (run-that
                        (run-self arg)))))))

(defmethod io map (mapper)
  (cond ((not (function? mapper))
         (error! "(io.map)" *e-arg-1* "function, got " (show mapper)))
        :else (let ((run-self (getf this 'unsafe-perform)))
                (io (lambda (arg)
                      (mapper (run-self arg)))))))

(defmethod io contramap (pre-mapper)
  (cond ((not (function? pre-mapper))
         (error! "(io.contramp)" *e-arg-1* "function, got " (show pre-mapper)))
        :else (let ((run-self (getf this 'unsafe-perform)))
                (io (lambda (arg)
                      (run-self (pre-mapper arg)))))))

(defmethod io promap (pre-mapper post-mapper)
  (cond ((not (function? pre-mapper))
         (error! "(io.promap)" *e-arg-1* "function, got " (show pre-mapper)))
        ((not (function? post-mapper))
         (error! "(io.promap)" *e-arg-2* "function, got " (show post-mapper)))
        :else (let ((run-self (getf this 'unsafe-perform)))
                (io (lambda (arg)
                      (post-mapper (run-self (pre-mapper arg))))))))

(defmethod io ap (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.ap)" *e-arg-1* "io, got " (show t-io)))
        :else (let ((run-self (getf this 'unsafe-perform)))
                (.map t-io run-self))))

(defmethod io flat-map (to-io-mapper)
  (cond ((not (function? to-io-mapper))
         (error! "(io.flat-map | io.chain)" *e-arg-1* "io returning function, got " (show to-io-mapper)))
        :else (let ((run-self (getf this 'unsafe-perform)))
                (io (lambda (arg)
                      (.unsafe-perform (to-io-mapper (run-self arg)) arg))))))

(setf io 'prototype 'chain (getf io 'prototype 'flat-map))

(defmethod io compose (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.compose)" *e-arg-1* "io, got " (show t-io)))
        :else (let ((run-self (getf this 'unsafe-perform))
                    (run-that (getf t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (run-that
                        (run-self arg)))))))

(defmethod io run-io (arg)
  (.unsafe-perform this arg))



;; --- maybe
(provide
  (defsum maybe ((nothing) (just value))))

(setf maybe 'of (lambda (value)
                 (maybe.just value)))

(setf maybe 'lift (lambda (value)
                   (cond ((not (exists? value))
                          (maybe.nothing))
                         :else (maybe.of value))))

(setf maybe 'empty (lambda () (maybe.nothing)))

(setf maybe 'zero (lambda () (maybe.nothing)))

(defmethod maybe to-string ()
  (.match this (hash nothing (lambda () 
                               "(maybe.nothing)")
                     just (lambda (value)
                            (+ "(maybe.just " (show value) ")")))))

(defmethod maybe equals (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.equals)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda ()
                          (.match t-maybe
                                  (hash nothing (lambda () true)
                                        just (lambda () false))))
                just (lambda (value)
                      (.match t-maybe 
                              (hash nothing (lambda ()
                                              false)
                                    just (lambda (t-value)
                                           (if (method? value equals)  
                                               (.equals value t-value)
                                               (eql? value t-value)))))))))

(defmethod maybe concat (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.concat)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda ()
                          (maybe.nothing))
                just (lambda (value)
                       (.match t-maybe
                               (hash nothing (lambda () t-maybe)
                                     just (lambda (t-value)
                                            (let ((cnt (getf value 'concat)))
                                              (when (not (function? cnt))
                                                (error! "(maybe.concat) can only concat when both of the carried values implement the semigroup typeclass"))
                                              (.call cnt value t-value)))))))))

(defmethod maybe map (mapper)
  (cond ((not (function? mapper))
         (error! "(maybe.map)" *e-arg-1* "function, got " (show mapper)))
        :else (.match this 
                      (hash nothing (lambda ()
                                      (maybe.nothing))
                            just (lambda (value) 
                                  (maybe.lift (mapper value))))))) 

(defmethod maybe ap (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.ap)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda () 
                          (maybe.nothing))
                just (lambda (value)
                      (.map t-maybe value)))))

(defmethod maybe flat-map (to-maybe-mapper)
  (cond ((not (function? to-maybe-mapper))
         (error! "(maybe.flat-map|maybe.chain)" *e-arg-1* "function, got " (show to-maybe-mapper)))
        :else (.match this
                      (hash nothing (lambda ()
                                      (maybe.nothing))
                            just (lambda (value)
                                  (to-maybe-mapper value))))))

(setf maybe 'prototype 'chain (getf maybe 'prototype 'flat-map))

(defmethod maybe bimap (transform-nothing transform-just)
  (cond ((not (function? transform-nothing))
         (error! "(maybe.bimap)" *e-arg-1* "function, got " (show transform-nothing)))
        ((not (function? transform-just))
         (error! "(maybe.bimap)" *e-arg-2* "function, got " (show transform-just)))
        :else (.match this
                      (hash nothing (lambda () (transform-nothing))
                            just (lambda (value) (transform-just value))))))

(defmethod maybe alt (t-maybe)
  (cond ((not (.is maybe t-maybe))
         (error! "(maybe.alt)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
        :else (.match this
                      (hash nothing (lambda () t-maybe)
                            just (lambda (value) (maybe.just value))))))

(defmethod maybe reduce (reducer seed)
  (cond ((not (function? reducer))
         (error! "(maybe.reduce)" *e-arg-1* "function, got " (show reducer)))
        ((not (defined? seed))
         (error! "(maybe.reduce)" *e-arg-2* "non (void) value, got " (show seed)))
        :else (.match this
                      (hash nothing (lambda () seed)
                            just (lambda (value) (reducer seed value))))))

(defmethod maybe traverse (lift transformer)
  (cond ((not (function? lift))
         (error! "(maybe.traverse)" *e-arg-1* "function, got " (show lift)))
        (not (function? transformer)
         (error! "(maybe.traverse)" *e-arg-2* "function, got " (show transformer)))
        :else (.match this
                      (hash nothing (lambda () 
                                      (lift (maybe.nothing)))
                            just (lambda (value)
                                  (.map (transformer value) maybe.of))))))

(defmethod maybe sequence (lift)
  (cond ((not (function? lift))
         (error! "(maybe.sequence)" *e-arg-1* "function, got " (show lift)))
        :else (.traverse this lift identity)))



;; --- either
(provide
  (defsum either ((left error)
                  (right value))))

(setf either 'of (lambda (value)
                  (either.right value)))

(setf either 'lift (lambda (value)
                    (cond ((not (exists? value))
                           (either.left (error "")))
                          :else (either.of value))))

(setf either 'empty (lambda ()
                     (either.right (list))))

(setf either 'zero (lambda ()
                    (either.left (error "either-zero"))))

(defmethod either to-string ()
  (.match this 
          (hash left (lambda (error) (+ "(either.left " (show error) ")")) 
                right (lambda (value) (+ "(either.right " (show value) ")")))))

(defmethod either equals (t-either)
  (cond ((not (.is either t-either))
         (error! "(either.equals)" *e-arg-1* "instance of either, got " (show t-either)))
        :else (.match this
                      (hash left (lambda ()
                                  (.match t-either
                                          (hash left (lambda () true)
                                                right (lambda () false))))
                            right (lambda (value)
                                    (.match t-either 
                                            (hash left (lambda () false)
                                                  right (lambda (t-value)
                                                          (ternary 
                                                            (method? value equals)  
                                                            (.equals value t-value)
                                                            (eql? value t-value))))))))))

(defmethod either concat (t-either)
  (cond ((not (.is either t-either))
         (error! "(either.concat)" *e-arg-1* "either, got " (show t-either)))
        :else (.match this
                      (hash left (lambda (error) (either.left error))
                            right (lambda (value)
                                    (.match t-either
                                            (hash left (lambda () t-either)
                                                  right (lambda (t-value)
                                                          (let ((cnt (getf value 'concat)))
                                                            (when (not (function? cnt))
                                                              (error! "(either.concat) cannot concat when both of the carried values implement the semigroup typeclass"))
                                                            (.call cnt value t-value))))))))))

(defmethod either map (mapper)
  (cond ((not (function? mapper))
         (error! "(either.map)" *e-arg-1* "function, got " (show mapper)))
        :else (.match this 
                      (hash left (lambda (error)
                                  (either.left error))
                            right (lambda (value) 
                                   (either.lift (mapper value))))))) 

(defmethod either ap (t-either)
  (when (not (.is either t-either))
    (error! "(either.ap)" *e-arg-1* "instance of either, got " (show t-either)))
  (.match this
          (hash left (lambda (error) 
                      (either.left error))
                right (lambda (value)
                       (.map t-either value)))))

(defmethod either flat-map (to-either-mapper)
  (cond ((not (function? to-either-mapper))
         (error! "(either.flat-map|either.chain)" *e-arg-1* "function, got " (show to-either-mapper)))
        :else (.match this
                      (hash left (lambda (error)
                                  (either.left error))
                            right (lambda (value)
                                   (to-either-mapper value))))))

(setf either 'prototype 'chain (getf either 'prototype 'flat-map))

(defmethod either bimap (transform-left transform-right)
  (cond ((not (function? transform-left))
         (error! "(either.bimap)" *e-arg-1* "function, got " (show transform-left)))
        ((not (function? transform-right))
         (error! "(either.bimap)" *e-arg-2* "function, got " (show transform-right)))
        :else (.match this
                      (hash left (lambda (error) (transform-left error))
                            right (lambda (value) (transform-right value))))))

(defmethod either alt (t-either)
  (cond ((not (.is either t-either))
         (error! "(either.alt)" *e-arg-1* "instance of either, got " (show t-either)))
        :else (.match this
                      (hash left (lambda () t-either)
                            right (lambda (value) (either.right value))))))

(defmethod either reduce (reducer seed)
  (cond ((not (function? reducer))
         (error! "(either.reduce)" *e-arg-1* "function, got " (show reducer)))
        ((not (defined? seed))
         (error! "(either.reduce)" *e-arg-2* "non (void) value, got " (show seed)))
        :else (.match this
                      (hash left (lambda () seed)
                            right (lambda (value) (reducer seed value))))))

(defmethod either traverse (lift transformer)
  (cond ((not (function? lift))
         (error! "(either.traverse)" *e-arg-1* "function, got " (show lift)))
        ((not (function? transformer))
         (error! "(either.traverse)" *e-arg-2* "function, got " (show transformer)))
        :else (.match this
                      (hash left (lambda (error) 
                                  (lift (either.left error)))
                            right (lambda (value)
                                   (.map (transformer value) either.of))))))

(defmethod either sequence (lift)
  (cond ((not (function? lift))
         (error! "(either.sequence)" *e-arg-1* "function, got " (show lift)))
        :else (.traverse this lift identity)))


;; --- proof
(provide
  (defsum proof ((falsy errors)
                 (truthy value))))

(setf proof 'of (lambda (value)
                 (proof.truthy value)))

(setf proof 'lift (lambda (value)
                   (cond ((nothing? value)
                          (proof.falsy (list (error *e-no-value*))))
                         ((error? value)
                          (proof.falsy (list value)))
                         :else (proof.truthy value))))

(setf proof 'empty (lambda ()
                    (proof.truthy true)))

(setf proof 'zero (lambda ()
                   (proof.falsy (list (error "ProofZero")))))

(defmethod proof equals (t-proof)
  (cond ((not (.is proof t-proof))
         (error! "(proof.equals)" *e-arg-1* "instance of proof, got " (show t-proof)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (.match t-proof
                                            (hash truthy (lambda (t-value)
                                                          (equals value t-value))
                                                  falsy (lambda () false))))
                            falsy (lambda (errors)
                                    (.match t-proof
                                            (hash truthy (lambda () false)
                                                  falsy (lambda (t-errors)
                                                          (.every errors
                                                                  (lambda (e i)
                                                                    (equals e
                                                                            (getf t-errors i))))))))))))

(defmethod proof concat (t-proof)
  (cond ((not (.is proof t-proof))
         (error! "(proof.concat)" *e-arg-1* "proof, got " (show t-proof)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (.match t-proof
                                            (hash truthy (lambda (t-value)
                                                          (proof.truthy t-value))
                                                  falsy (lambda (errors)
                                                          (proof.falsy errors)))))
                            falsy (lambda (errors)
                                    (.match t-proof
                                            (hash truthy (lambda ()
                                                          (proof.falsy errors))
                                                  falsy (lambda (t-errors)
                                                          (proof.falsy 
                                                            (.concat errors
                                                                     t-errors))))))))))

(defmethod proof map (mapper)
  (cond ((not (function? mapper))
         (error! "(proof.map)" *e-arg-1* "function, got " (show mapper)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (proof.lift (mapper value)))
                            falsy (lambda (errors)
                                    (proof.falsy errors))))))
                    
(defmethod proof bimap (lhs-mapper rhs-mapper)
  (cond ((not (function? lhs-mapper))
         (error! "(proof.bimap)" *e-arg-1* "function, got " (show lhs-mapper)))
        ((not (function? rhs-mapper))
         (error! "(proof.bimap)" *e-arg-2* "function, got " (show rhs-mapper)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (proof.lift (rhs-mapper value)))
                            falsy (lambda (errors)
                                    (proof.falsy (.map errors lhs-mapper)))))))

(defmethod proof ap (t-proof)
  (cond ((not (.is proof t-proof))
         (error! "(proof.ap)" *e-arg-1* "proof, got " (show t-proof)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (.match t-proof
                                            (hash truthy (lambda (t-value)
                                                          (proof.lift (value t-value)))
                                                  falsy (lambda (t-errors)
                                                          (proof.falsy t-errors)))))
                            falsy (lambda (errors)
                                    (.match t-proof
                                            (hash truthy (lambda ()
                                                          (proof.falsy errors))
                                                  falsy (lambda (t-errors)
                                                          (proof.falsy 
                                                            (.concat errors 
                                                                     t-errors))))))))))

(defmethod proof alt (t-proof)
  (cond ((not (.is proof t-proof))
         (error! "(proof.alt)" *e-arg-1* "proof, got " (show t-proof)))
        :else (.match this
                      (hash truthy (lambda (value) (proof.truthy value))
                            falsy (lambda () t-proof)))))



;; --- task
(provide
  (deftype task (run-task)))

(setf task 'of (lambda (value)
                (task (lambda (fail ok)
                        (ok value)))))

(setf task 'zero (lambda (value)
                    (task (lambda (fail)
                            (fail
                              (ternary (error? value)
                                       value
                                       (error "TaskZero" value)))))))

(setf task 'lift (lambda (value)
                  (task (lambda (fail ok)
                          (cond ((or (nothing? value)
                                     (error? value))
                                 (fail value))
                                :else (ok value))))))
                                           
(setf task 'empty (lambda ()
                    (task (lambda (fail ok)))))

(setf task 'resolve (getf task 'of))

(setf task 'reject (getf task 'zero))

(defmethod task concat (t-task)
  (cond ((not (instance-of? t-task task))
         (error! "(task.concat)" *e-arg-1* "instance of task, got " (show t-task)))
        :else (let ((run-self (getf this 'run-task))
                    (run-that (getf t-task 'run-task)))
                (task
                  (lambda (fail ok)
                    (let ((done false)
                          (guard (lambda (f)
                                   (lambda (g)
                                    (when (not done)
                                      (assign done true)
                                      (f g))))))
                      (run-self (guard fail) (guard ok))
                      (run-that (guard fail) (guard ok))))))))

(defmethod task ap (t-task)
  (cond ((not (instance-of? t-task task))
         (error! "(task.ap)" *e-arg-1* "instance of task, got " (show t-task)))
        :else (let ((run-self (getf this 'run-task))
                    (run-that (getf t-task 'run-task)))
                (task
                  (lambda (fail ok)
                    (let ((adone false)
                          (bdone false)
                          (aval false)
                          (bval false)
                          (rejected false)
                          (rej (lambda (v)
                                (when (not rejected)
                                  (assign rejected true)
                                  (fail v))))
                          (res (lambda (f)
                                (lambda (v)
                                  (when (not rejected)
                                    (f v)
                                    (if (and adone bdone)
                                        (ok (call aval bval))
                                        v))))))
                      (run-self rej (res (lambda (a)
                                          (assign adone true)
                                          (assign aval a))))
                      (run-that rej (res (lambda (b)
                                          (assign bdone true)
                                          (assign bval b))))))))))

(defmethod task map (mapper)
  (cond ((not (function? mapper))
         (error! "(task.map)" *e-arg-1* "function, got " (show mapper)))
        :else (let ((run (getf this 'run-task)))
                (task (lambda (fail ok)
                        (run fail (lambda (value)
                                    (ok (mapper value)))))))))

(defmethod task flat-map (to-task-mapper)
  (cond ((not (function? to-task-mapper))
         (error! "(task.flat-map)" *e-arg-1* "function, got " (show to-task-mapper)))
        :else (let ((run (getf this 'run-task)))
                (task (lambda (fail ok)
                        (run fail (lambda (value)
                                    (.run-task (to-task-mapper value) fail ok))))))))

(setf task 'prototype 'chain (getf task 'prototype 'flat-map))

(defmethod task bimap (lhs-mapper rhs-mapper)
  (cond ((not (function? lhs-mapper))
         (error! "(task.bimap)" *e-arg-1* "function, got " (show lhs-mapper)))
        ((not (function? rhs-mapper))
         (error! "(task.bimap)" *e-arg-2* "function, got " (show rhs-mapper)))
        :else (let ((run (getf this 'run-task)))
                (task (lambda (fail ok)
                        (run (lambda (exc)
                              (fail (lhs-mapper exc)))
                             (lambda (value)
                              (ok (rhs-mapper value)))))))))

(defmethod task alt (t-task)
  (cond ((not (instance-of t-task task))
         (error! "(task.alt)" *e-arg-1* "instance of task, got " (show t-task)))
        :else (let ((run-self (getf this 'run-task))
                    (run-that (getf t-task 'run-task)))
                (task (lambda (fail ok)
                        (run-self (lambda () (run-that fail ok))
                                  ok))))))
