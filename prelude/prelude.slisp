(comment sibilisp-prelude - MIT)

;;; BASIC LAMBDA OPERATORS (I, K, S)
(provide
 (defun identity (a) a))

(provide
 (defun thunk (a)
   (lambda () a)))


;;; LANGUAGE TYPE CHECK UTILITIES
(provide
  (defun list-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(list-of? expects argument 2 to
					 				 be a function, got " predicate))
          :else (and (list? x)
                     (.every x predicate)))))

(provide
  (defun hash-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(hash-of? expects argument 2 to 
					 				 be a function, got " predicate))
          :else (and (hash? x)
                     (.every (hash-pairs x) (lambda ([_ v]) (predicate v)))))))

(provide 
  (defun dict-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(dict-of?) expects argument 2 to 
					 				 be a function, got " predicate))
          :else (and (dict? x)
                     (.every (.entries x) (lambda ([_ v]) (predicate v)))))))



;;; FUNCTION FUNCTIONS
(provide
  (defun converge (combine branches)
    (cond ((not (function? combine))
           (error! "(converge) expects argument 1 to
					 				 be a function, got " combine))
          ((not (list-of? branches (lambda (v) (function? v))))
           (error! "(converge) expects argument 2 to
					 				 be a list of functions, got " branches))
          :else (lambda (...args)
                  (cond ((not (= (length args) (length branches)))
                         (error! "(converge -> lambda) expects arguments
												 				 length (" (length args) ") to equal the number
																 of branches (" (length branches) ") but they
																 differ."))
                        :else (.apply converge
                                      (nil)
                                      (.map branches
                                            (lambda (branch i)
                                              (branch (get args i)
                                                      i
                                                      args)))))))))



;;; GENERAL PURPOSE OPERATIONS
(provide
  (defun show (x)
    (cond ((eq? (nil) x)
           "(nil)")
          ((nan? x)
           "(nan)")
          ((string? x)
           (+ "(string " x ")"))
          ((number? x)
           (+ "(number " x ")"))
          ((function? x)
           (+ "(function " (or (get x 'name) "lambda") ")"))
          ((generator? x)
           (+ "(generator " (get x 'name) ")"))
          ((list? x)
           (+ "(list" (.reduce x (lambda (a v)
                                   (+ a " " (show v))) "") ")"))
          ((hash? x)
           (+ "(hash" (.reduce (hash-pairs x)
                               (lambda (a [k v])
                                (+ a " :" k " " (show v))) "") ")"))
          ((dict? x)
           (+ "(dict" (.reduce (.entries x)
                               (lambda (a [k v])
                                 (+ a " :" (show k) " " (show v)))
                               "") ")"))
          ((future? x)
           "(future)")
          ((date? x)
           (+ "(date" (.get-full-year x)
              "-" (+ 1 (.get-month x))
              "-" (.get-date x) ")"))
          ((regex? x)
           (+ "(regex " (get x 'source) " :flags " (get x 'flags) ")"))
          :else (.to-string x))))


;;; ALGEBRAIC TYPES

;; --- coyo (-neda)
(provide
  (deftype coyo (value mapper)))

(set coyo 'of (lambda (value)
                (coyo value identity)))

(set coyo 'lift (lambda (value)
                  (cond ((not (exists? value))
                         (error! "(coyo.lift) guards against (void) or
                                 (nil) values, got" value))
                        :else (coyo.of value))))

(defmethod coyo to-string ()
  (let ((value (get this 'value))
        (fn (get this 'mapper)))
    (+ "(coyo " (show value) " " (show fn) ")")))

(defmethod coyo map (mapper)
  (cond ((not (function? mapper))
         (error! "(coyo.map) expects argument 1 to be
                 a function, got " (show mapper)))
        :else (let ((value (get this 'value))
                    (run-self (get this 'mapper)))
                (coyo value (lambda (arg) (mapper (run-self arg)))))))

(defmethod coyo lower ()
  (let ((mapper (get this 'mapper))
        (value (get this 'value)))
    (cond ((not (function? mapper))
           (error! "(coyo.lower) requires the coyo:mapper property
                   to hold a function, but it holds " (show mapper)))
          ((not (exists? value))
           (error! "(coyo.lower) requires the coyo:value property
                   to hold a non (void) or (nil) value, but it holds "
                   (show value)))
          ((not (function? (get value 'map)))
           (error! "(coyo.lower) requires the coyo:value property
                   to implement the functor typeclass but it doesn't"))
          :else (coyo (.map value mapper) identity))))

(defmethod coyo reduce (reducer seed)
  (let ((value (get this 'value))
        (mapper (get this 'mapper)))
    (cond ((not (function? reducer))
           (error! "(coyo.reduce) expects argument 1 to be
                   a function, got " (show reducer)))
          ((not (defined? seed))
           (error! "(coyo.reduce) expects argument 2 to be
                   a non (void) value, got " (show seed)))
          ((function? (get value 'map) (get value 'reduce))
           (.reduce value
                    (lambda (acc val)
                      (reducer acc (mapper val)))
                    seed))
          :else (reducer seed (mapper value)))))


;; --- io
(provide
  (deftype io (unsafe-perform)))

(set io 'of (lambda (value)
              (io (lambda () value))))

(set io 'lift (lambda (value)
                (cond ((not (exists? value))
                       (error! "(io.lift) guards agains (void) or
                               (nil) values, got " value))
                      :else (io.of value))))

(set io 'empty (lambda ()
                (io (lambda (value) value))))

(set io 'identity (get io 'empty))

(defmethod io to-string ()
  (let ((fn (get this 'unsafe-perform)))
    (+ "(io " (show fn) ")")))

(defmethod io equals (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.equals) expects argument 1 to be
                 an io, got " (show t-io)))
        :else (eql? (get this 'unsafe-perform)
                    (get t-io 'unsafe-perform))))

(defmethod io concat (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.concat) expects argument 1 to be
                 an io, got " (show t-io)))
        :else (let ((run-self (get this 'unsafe-perform))
                    (run-that (get t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (run-that
                        (run-self arg)))))))

(defmethod io map (mapper)
  (cond ((not (function? mapper))
         (error! "(io.map) expects argument 1 to be
                 a function, got " (show mapper)))
        :else (let ((run-self (get this 'unsafe-perform)))
                (io (lambda (arg)
                      (mapper (run-self arg)))))))

(defmethod io ap (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.ap) expects argument 1 to be
                 an io, got " (show t-io)))
        :else (let ((run-self (get this 'unsafe-perform))
                    (run-that (get t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (call (run-self run-that) arg))))))

(defmethod io flat-map (to-io-mapper)
  (cond ((not (function? to-io-mapper))
         (error! "(io.flat-map | io.chain) expects argument 1 to be
                 an io returning function, got " (show to-io-mapper)))
        :else (let ((run-self (get this 'unsafe-perform)))
                (io (lambda (arg)
                      (.unsafe-perform (to-io-mapper (run-self arg)) arg))))))

(set (get io 'prototype) 'chain (get io 'prototype 'flat-map))

(defmethod io compose (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.compose) expects argument 1 to be
                 an io, got " (show t-io)))
        :else (let ((run-self (get this 'unsafe-perform))
                    (run-that (get t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (run-that
                        (run-self arg)))))))

(defmethod io run-io (arg)
  (.unsafe-perform this arg))



;; --- maybe
(provide
  (defsum maybe ((nothing) (just value))))

(set maybe 'of (lambda (value)
                (maybe.just value)))

(set maybe 'lift (lambda (value)
                  (cond ((not (exists? value))
                         (maybe.nothing))
                        :else (maybe.of value))))

(set maybe 'empty (lambda ()
                    (maybe.nothing)))

(set maybe 'zero (lambda ()
                  (maybe.nothing)))

(defmethod maybe to-string ()
  (.match this (hash nothing (lambda () 
                               "(maybe.nothing)")
                     just (lambda (value)
                            (+ "(maybe.just " (show value) ")")))))

(defmethod maybe equals (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.equals) expects argument 1 to be
            an instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda ()
                          (.match t-maybe
                                  (hash nothing (lambda () true)
                                        just (lambda () false))))
                just (lambda (value)
                      (.match t-maybe 
                              (hash nothing (lambda ()
                                              false)
                                    just (lambda (t-value)
                                           (if (function? (get value 'equals))  
                                               (.equals value t-value)
                                               (eql? value t-value)))))))))

(defmethod maybe concat (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.concat) expects argument 1 to be
            an instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda ()
                          (maybe.nothing))
                just (lambda (value)
                       (.match t-maybe
                               (hash nothing (lambda () t-maybe)
                                     just (lambda (t-value)
                                            (let ((cnt (get value 'concat)))
                                              (when (not (function? cnt))
                                                (error! "(maybe.concat) cannot
                                                        concat when both of
                                                        the carried values
                                                        implement the
                                                        semigroup
                                                        typeclass"))
                                              (.call cnt value t-value)))))))))

(defmethod maybe map (mapper)
  (cond ((not (function? mapper))
         (error! "(maybe.map) expects argument 1 to be
                 a function, got " (show mapper)))
        :else (.match this 
                      (hash nothing (lambda ()
                                      (maybe.nothing))
                            just (lambda (value) 
                                  (maybe-lift (mapper value))))))) 

(defmethod maybe ap (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.ap) expects argument 1 to be
            a maybe.nothing or maybe.just, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda () 
                          (maybe.nothing))
                just (lambda (value)
                      (.map t-maybe value)))))

(defmethod maybe flat-map (to-maybe-mapper)
  (cond ((not (function? to-maybe-mapper))
         (error! "(maybe.flat-map|maybe.chain) expects argument 1 to be
                 a function, got " (show to-maybe-mapper)))
        :else (.match this
                      (hash nothing (lambda ()
                                      (maybe.nothing))
                            just (lambda (value)
                                  (to-maybe-mapper value))))))

(set (get maybe 'prototype) 'chain (get maybe 'prototype 'flat-map))

(defmethod maybe alt (t-maybe)
  (cond ((not (.is maybe t-maybe))
         (error! "(maybe.alt) expects argument 1 to be
                 a maybe.nothing or maybe.just, got " (show t-maybe)))
        :else (.match this
                      (hash nothing (lambda () t-maybe)
                            just (lambda (value) (maybe.just value))))))

(defmethod maybe reduce (reducer seed)
  (cond ((not (function? reducer))
         (error! "(maybe.reduce) expects argument 1 to be
                 a function, got " (show reducer)))
        ((not (defined? seed))
         (error! "(maybe.reduce) expects argument 2 to be
                 a non (void) value, got " (show seed)))
        :else (.match this
                      (hash nothing (lambda () seed)
                            just (lambda (value) (reducer seed value))))))

(defmethod maybe traverse (lift transformer)
  (cond ((not (function? lift))
         (error! "(maybe.traverse) expects argument 1 to be
                 a function, got " (show lift)))
        (not (function? transformer)
         (error! "(maybe.traverse) expects argument 2 to be
                 a function, got " (show transformer)))
        :else (.match this
                      (hash nothing (lambda () 
                                      (lift (maybe.nothing)))
                            just (lambda (value)
                                  (.map (transformer value) maybe-of))))))

(defmethod maybe sequence (lift)
  (cond ((not (function? lift))
         (error! "(maybe.sequence) expects argument 1 to be
                 a function, got " (show lift)))
        :else (.traverse this lift identity)))
