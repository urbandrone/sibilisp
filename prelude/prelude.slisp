(comment sibilisp-prelude - MIT)

;;; CONSTANTS
(defconstant *e-no-value* "E_NO_VALUE")
(defconstant *e-guard* " guards agains (nil) and (void) values, got")
(defconstant *e-arg-1* " expects argument 1 to be a ")
(defconstant *e-arg-2* " expects argument 2 to be a ")

;;; BASIC LAMBDA OPERATORS (I, K, S)
(provide
 (defun identity (a) a))

(provide
 (defun thunk (a)
   (lambda () a)))


;;; LANGUAGE TYPE CHECK UTILITIES
(provide
  (defun list-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(list-of?)" *e-arg-2* "function, got " predicate))
          :else (and (list? x)
                     (.every x predicate)))))

(provide
  (defun hash-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(hash-of?)" *e-arg-2* "function, got " predicate))
          :else (and (hash? x)
                     (.every (hash-pairs x) (lambda ([_ v]) (predicate v)))))))

(provide 
  (defun dict-of? (x predicate)
    (cond ((not (function? predicate))
           (error! "(dict-of?)" *e-arg-2* "function, got " predicate))
          :else (and (dict? x)
                     (.every (.entries x) (lambda ([_ v]) (predicate v)))))))



;;; FUNCTION FUNCTIONS
(provide
  (defun converge (combine branches)
    (cond ((not (function? combine))
           (error! "(converge)" *e-arg-1* "function, got " combine))
          ((not (list-of? branches (lambda (v) (function? v))))
           (error! "(converge)" *e-arg-2* "list of functions, got " branches))
          :else (lambda (...args)
                  (cond ((not (= (length args) (length branches)))
                         (error! "(converge -> lambda) expects arguments
												 				 length (" (length args) ") to equal the number
																 of branches (" (length branches) ") but they
																 differ."))
                        :else (.apply converge
                                      (nil)
                                      (.map branches
                                            (lambda (branch i)
                                              (branch (get args i)
                                                      i
                                                      args)))))))))



;;; GENERAL PURPOSE OPERATIONS
(provide
  (defun show (x)
    (cond ((eq? (nil) x)
           "(nil)")
          ((nan? x)
           "(nan)")
          ((string? x)
           (+ "(string " x ")"))
          ((number? x)
           (+ "(number " x ")"))
          ((function? x)
           (+ "(function " (or (get x 'name) "lambda") ")"))
          ((generator? x)
           (+ "(generator " (get x 'name) ")"))
          ((list? x)
           (+ "(list" (.reduce x (lambda (a v)
                                   (+ a " " (show v))) "") ")"))
          ((hash? x)
           (+ "(hash" (.reduce (hash-pairs x)
                               (lambda (a [k v])
                                (+ a " :" k " " (show v))) "") ")"))
          ((dict? x)
           (+ "(dict" (.reduce (.entries x)
                               (lambda (a [k v])
                                 (+ a " :" (show k) " " (show v)))
                               "") ")"))
          ((future? x)
           "(future)")
          ((date? x)
           (+ "(date" (.get-full-year x)
              "-" (+ 1 (.get-month x))
              "-" (.get-date x) ")"))
          ((regex? x)
           (+ "(regex " (get x 'source) " :flags " (get x 'flags) ")"))
          :else (.to-string x))))


(provide
  (defun equals (value-a value-b)
      (cond ((nil? value-a) (nil? value-b))
            ((void? value-a) (void? value-b))
            ((string? value-a value-b) (eql? value-a value-b))
            ((function? value-a value-b) (eql? value-a value-b))
            ((number? value-a value-b) (eql? value-a value-b))
            ((regex? value-a value-b) (and (eql? (get value-a 'source)
                                                 (get value-b 'source))
                                           (eql? (get value-a 'flag)
                                                 (get value-b 'flag))))
            ((date? value-a value-b) (eql? (as-number value-a)
                                           (as-number value-b)))
            ((generator? value-a value-b) (eql? value-a value-b))
            ((future? value-a value-b) (eql? value-a value-b))
            ((list? value-a value-b) (and (eql? (length value-a)
                                                (length value-b))
                                          (.every 
                                            value-a
                                            (lambda (va i)
                                              (equals va (get value-b i))))))
            ((hash? value-a value-b) (let ((pa (hash-pairs value-a))
                                           (pb (hash-pairs value-b)))
                                      (and (eql? (length pa) (length pb))
                                           (.every 
                                            pa
                                            (lambda ([k v])
                                              (equals v (get value-b k)))))))
            ((dict? value-a value-b) (let ((pa (dict-pairs value-a))
                                           (pb (dict-pairs value-b)))
                                      (and (eql? (length pa) (length pb))
                                           (.every
                                            pa
                                            (lambda ([k v])
                                              (equals v (.get value-b k)))))))
            ((function? (get value-a 'equals)) (.equals value-a value-b))
            :else false)))

(provide
  (defun concat (value-a value-b)
    (cond ((or (not (exists? value-a)) (not (exists? value-b)))
           (error! "(concat)"))
          ((string? value-a value-b) (+ value-a value-b))
          ((function? value-a value-b) (lambda (arg) (value-b (value-a arg))))
          ((list? value-a value-b) (.concat value-a value-b))
          ((future? value-a value-b) (future-all value-a value-b))
          ((function? (get value-a 'concat)) (.concat value-a value-b))
          :else (error! "(concat)"))))
          


;;; ALGEBRAIC TYPES

;; --- coyo (-neda)
(provide
  (deftype coyo (value mapper)))

(set coyo 'of (lambda (value)
                (coyo value identity)))

(set coyo 'lift (lambda (value)
                  (cond ((not (exists? value))
                         (error! "(coyo.lift)" *e-guard* value))
                        :else (coyo.of value))))

(defmethod coyo to-string ()
  (let ((value (get this 'value))
        (fn (get this 'mapper)))
    (+ "(coyo " (show value) " " (show fn) ")")))

(defmethod coyo map (mapper)
  (cond ((not (function? mapper))
         (error! "(coyo.map)" *e-arg-1* "function, got " (show mapper)))
        :else (let ((value (get this 'value))
                    (run-self (get this 'mapper)))
                (coyo value (lambda (arg) (mapper (run-self arg)))))))

(defmethod coyo lower ()
  (let ((mapper (get this 'mapper))
        (value (get this 'value)))
    (cond ((not (function? mapper))
           (error! "(coyo.lower) requires the coyo:mapper property
                   to hold a function, but it holds " (show mapper)))
          ((not (exists? value))
           (error! "(coyo.lower) requires the coyo:value property
                   to hold a non (void) or (nil) value, but it holds "
                   (show value)))
          ((not (function? (get value 'map)))
           (error! "(coyo.lower) requires the coyo:value property
                   to implement the functor typeclass but it doesn't"))
          :else (coyo (.map value mapper) identity))))

(defmethod coyo reduce (reducer seed)
  (let ((value (get this 'value))
        (mapper (get this 'mapper)))
    (cond ((not (function? reducer))
           (error! "(coyo.reduce)" *e-arg-1* "function, got " (show reducer)))
          ((not (defined? seed))
           (error! "(coyo.reduce)" *e-arg-2* "non (void) value, got " (show seed)))
          ((function? (get value 'map) (get value 'reduce))
           (.reduce value
                    (lambda (acc val)
                      (reducer acc (mapper val)))
                    seed))
          :else (reducer seed (mapper value)))))


;; --- io
(provide
  (deftype io (unsafe-perform)))

(set io 'of (lambda (value)
              (io (lambda () value))))

(set io 'lift (lambda (value)
                (cond ((not (exists? value))
                       (error! "(io.lift)" *e-guard* value))
                      :else (io.of value))))

(set io 'empty (lambda ()
                (io (lambda (value) value))))

(set io 'identity (get io 'empty))

(defmethod io to-string ()
  (let ((fn (get this 'unsafe-perform)))
    (+ "(io " (show fn) ")")))

(defmethod io equals (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.equals)" *e-arg-1* "io, got " (show t-io)))
        :else (eql? (get this 'unsafe-perform)
                    (get t-io 'unsafe-perform))))

(defmethod io concat (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.concat)" *e-arg-1* "io, got " (show t-io)))
        :else (let ((run-self (get this 'unsafe-perform))
                    (run-that (get t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (run-that
                        (run-self arg)))))))

(defmethod io map (mapper)
  (cond ((not (function? mapper))
         (error! "(io.map)" *e-arg-1* "function, got " (show mapper)))
        :else (let ((run-self (get this 'unsafe-perform)))
                (io (lambda (arg)
                      (mapper (run-self arg)))))))

(defmethod io ap (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.ap)" *e-arg-1* "io, got " (show t-io)))
        :else (let ((run-self (get this 'unsafe-perform))
                    (run-that (get t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (call (run-self run-that) arg))))))

(defmethod io flat-map (to-io-mapper)
  (cond ((not (function? to-io-mapper))
         (error! "(io.flat-map | io.chain)" *e-arg-1* "io returning function, got " (show to-io-mapper)))
        :else (let ((run-self (get this 'unsafe-perform)))
                (io (lambda (arg)
                      (.unsafe-perform (to-io-mapper (run-self arg)) arg))))))

(set (get io 'prototype) 'chain (get io 'prototype 'flat-map))

(defmethod io compose (t-io)
  (cond ((not (instance-of? t-io io))
         (error! "(io.compose)" *e-arg-1* "io, got " (show t-io)))
        :else (let ((run-self (get this 'unsafe-perform))
                    (run-that (get t-io 'unsafe-perform)))
                (io (lambda (arg)
                      (run-that
                        (run-self arg)))))))

(defmethod io run-io (arg)
  (.unsafe-perform this arg))



;; --- maybe
(provide
  (defsum maybe ((nothing) (just value))))

(set maybe 'of (lambda (value)
                (maybe.just value)))

(set maybe 'lift (lambda (value)
                  (cond ((not (exists? value))
                         (maybe.nothing))
                        :else (maybe.of value))))

(set maybe 'empty (lambda ()
                    (maybe.nothing)))

(set maybe 'zero (lambda ()
                  (maybe.nothing)))

(defmethod maybe to-string ()
  (.match this (hash nothing (lambda () 
                               "(maybe.nothing)")
                     just (lambda (value)
                            (+ "(maybe.just " (show value) ")")))))

(defmethod maybe equals (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.equals)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda ()
                          (.match t-maybe
                                  (hash nothing (lambda () true)
                                        just (lambda () false))))
                just (lambda (value)
                      (.match t-maybe 
                              (hash nothing (lambda ()
                                              false)
                                    just (lambda (t-value)
                                           (if (function? (get value 'equals))  
                                               (.equals value t-value)
                                               (eql? value t-value)))))))))

(defmethod maybe concat (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.concat)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda ()
                          (maybe.nothing))
                just (lambda (value)
                       (.match t-maybe
                               (hash nothing (lambda () t-maybe)
                                     just (lambda (t-value)
                                            (let ((cnt (get value 'concat)))
                                              (when (not (function? cnt))
                                                (error! "(maybe.concat) cannot
                                                        concat when both of
                                                        the carried values
                                                        implement the
                                                        semigroup
                                                        typeclass"))
                                              (.call cnt value t-value)))))))))

(defmethod maybe map (mapper)
  (cond ((not (function? mapper))
         (error! "(maybe.map)" *e-arg-1* "function, got " (show mapper)))
        :else (.match this 
                      (hash nothing (lambda ()
                                      (maybe.nothing))
                            just (lambda (value) 
                                  (maybe.lift (mapper value))))))) 

(defmethod maybe ap (t-maybe)
  (when (not (.is maybe t-maybe))
    (error! "(maybe.ap)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
  (.match this
          (hash nothing (lambda () 
                          (maybe.nothing))
                just (lambda (value)
                      (.map t-maybe value)))))

(defmethod maybe flat-map (to-maybe-mapper)
  (cond ((not (function? to-maybe-mapper))
         (error! "(maybe.flat-map|maybe.chain)" *e-arg-1* "function, got " (show to-maybe-mapper)))
        :else (.match this
                      (hash nothing (lambda ()
                                      (maybe.nothing))
                            just (lambda (value)
                                  (to-maybe-mapper value))))))

(set (get maybe 'prototype) 'chain (get maybe 'prototype 'flat-map))

(defmethod maybe bimap (transform-nothing transform-just)
  (cond ((not (function? transform-nothing))
         (error! "(maybe.bimap)" *e-arg-1* "function, got " (show transform-nothing)))
        ((not (function? transform-just))
         (error! "(maybe.bimap)" *e-arg-2* "function, got " (show transform-just)))
        :else (.match this
                      (hash nothing (lambda () (transform-nothing))
                            just (lambda (value) (transform-just value))))))

(defmethod maybe alt (t-maybe)
  (cond ((not (.is maybe t-maybe))
         (error! "(maybe.alt)" *e-arg-1* "instance of maybe, got " (show t-maybe)))
        :else (.match this
                      (hash nothing (lambda () t-maybe)
                            just (lambda (value) (maybe.just value))))))

(defmethod maybe reduce (reducer seed)
  (cond ((not (function? reducer))
         (error! "(maybe.reduce)" *e-arg-1* "function, got " (show reducer)))
        ((not (defined? seed))
         (error! "(maybe.reduce)" *e-arg-2* "non (void) value, got " (show seed)))
        :else (.match this
                      (hash nothing (lambda () seed)
                            just (lambda (value) (reducer seed value))))))

(defmethod maybe traverse (lift transformer)
  (cond ((not (function? lift))
         (error! "(maybe.traverse)" *e-arg-1* "function, got " (show lift)))
        (not (function? transformer)
         (error! "(maybe.traverse)" *e-arg-2* "function, got " (show transformer)))
        :else (.match this
                      (hash nothing (lambda () 
                                      (lift (maybe.nothing)))
                            just (lambda (value)
                                  (.map (transformer value) maybe.of))))))

(defmethod maybe sequence (lift)
  (cond ((not (function? lift))
         (error! "(maybe.sequence)" *e-arg-1* "function, got " (show lift)))
        :else (.traverse this lift identity)))



;; --- either
(provide
  (defsum either ((left error)
                  (right value))))

(set either 'of (lambda (value))
                (either.right value))

(set either 'lift (lambda (value))
                  (cond ((not (exists? value))
                         (either.left (error "")))
                        :else (either.of value)))

(set either 'empty (lambda ()
                    (either.right (list))))

(set either 'zero (lambda ())
                  (either.left (error "either-zero")))

(defmethod either to-string ()
  (.match this (hash left (lambda (error) 
                               "(either.left " (show error) ")")
                     right (lambda (value)
                            (+ "(either.right " (show value) ")")))))

(defmethod either equals (t-either)
  (when (not (.is either t-either))
    (error! "(either.equals)" *e-arg-1* "instance of either, got " (show t-either)))
  (.match this
          (hash left (lambda ()
                      (.match t-either
                              (hash left (lambda () true)
                                    right (lambda () false))))
                right (lambda (value)
                        (.match t-either 
                                (hash left (lambda ()
                                            false)
                                      right (lambda (t-value)
                                             (if (function? (get value 'equals))  
                                                 (.equals value t-value)
                                                 (eql? value t-value)))))))))

(defmethod either concat (t-either)
  (when (not (.is either t-either))
    (error! "(either.concat)" *e-arg-1* "instance of either, got " (show t-either)))
  (.match this
          (hash left (lambda (error) (either.left error))
                right (lambda (value)
                       (.match t-either
                               (hash left (lambda () t-either)
                                     right (lambda (t-value)
                                            (let ((cnt (get value 'concat)))
                                              (when (not (function? cnt))
                                                (error! "(either.concat) cannot
                                                        concat when both of
                                                        the carried values
                                                        implement the
                                                        semigroup
                                                        typeclass"))
                                              (.call cnt value t-value)))))))))

(defmethod either map (mapper)
  (cond ((not (function? mapper))
         (error! "(either.map)" *e-arg-1* "function, got " (show mapper)))
        :else (.match this 
                      (hash left (lambda (error)
                                  (either.left error))
                            right (lambda (value) 
                                   (either.lift (mapper value))))))) 

(defmethod either ap (t-either)
  (when (not (.is either t-either))
    (error! "(either.ap)" *e-arg-1* "instance of either, got " (show t-either)))
  (.match this
          (hash left (lambda (error) 
                      (either.left error))
                right (lambda (value)
                       (.map t-either value)))))

(defmethod either flat-map (to-either-mapper)
  (cond ((not (function? to-either-mapper))
         (error! "(either.flat-map|either.chain)" *e-arg-1* "function, got " (show to-either-mapper)))
        :else (.match this
                      (hash left (lambda (error)
                                  (either.left error))
                            right (lambda (value)
                                   (to-either-mapper value))))))

(set (get either 'prototype) 'chain (get either 'prototype 'flat-map))

(defmethod either bimap (transform-left transform-right)
  (cond ((not (function? transform-left))
         (error! "(either.bimap)" *e-arg-1* "function, got " (show transform-left)))
        ((not (function? transform-right))
         (error! "(either.bimap)" *e-arg-2* "function, got " (show transform-right)))
        :else (.match this
                      (hash left (lambda (error) (transform-left error))
                            right (lambda (value) (transform-right value))))))

(defmethod either alt (t-either)
  (cond ((not (.is either t-either))
         (error! "(either.alt)" *e-arg-1* "instance of either, got " (show t-either)))
        :else (.match this
                      (hash left (lambda () t-either)
                            right (lambda (value) (either.right value))))))

(defmethod either reduce (reducer seed)
  (cond ((not (function? reducer))
         (error! "(either.reduce)" *e-arg-1* "function, got " (show reducer)))
        ((not (defined? seed))
         (error! "(either.reduce)" *e-arg-2* "non (void) value, got " (show seed)))
        :else (.match this
                      (hash left (lambda () seed)
                            right (lambda (value) (reducer seed value))))))

(defmethod either traverse (lift transformer)
  (cond ((not (function? lift))
         (error! "(either.traverse)" *e-arg-1* "function, got " (show lift)))
        (not (function? transformer)
         (error! "(either.traverse)" *e-arg-2* "function, got " (show transformer)))
        :else (.match this
                      (hash left (lambda (error) 
                                  (lift (either.left error)))
                            right (lambda (value)
                                   (.map (transformer value) either.of))))))

(defmethod either sequence (lift)
  (cond ((not (function? lift))
         (error! "(either.sequence)" *e-arg-1* "function, got " (show lift)))
        :else (.traverse this lift identity)))


;; --- proof
(provide
  (defsum proof ((falsy errors)
                 (truthy value))))

(set proof 'of (lambda (value)
                (proof.truthy value)))

(set proof 'lift (lambda (value)
                  (cond ((nothing? value)
                         (proof.falsy (list (error *e-no-value*))))
                        ((error? value)
                         (proof.falsy (list value)))
                        :else (proof.truthy value))))

(set proof 'empty (lambda ()
                    (proof.truthy true)))

(set proof 'zero (lambda ()
                  (proof.falsy false)))

(defmethod proof equals (t-proof)
  (cond ((not (.is proof t-proof))
         (error! "(proof.equals)" *e-arg-1* "instance of proof, got " (show t-proof)))
        :else (.match this
                      (hash truthy (lambda (value)
                                    (.match t-proof
                                            (hash truthy (lambda (t-value)
                                                          (equals value
                                                                  t-value))
                                                  falsy (lambda ()
                                                          false))))
                            falsy (lambda (errors)
                                    (.match t-proof
                                            (hash truthy (lambda () false)
                                                  falsy (lambda (t-errors)
                                                          (.every errors
                                                                  (lambda (e i)
                                                                    (equals e
                                                                            (get t-errors i))))))))))))
                                              
